<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://fanyuecheng.github.io</id>
    <title>fanyuecheng&apos;s blog</title>
    <updated>2023-10-11T04:41:21.281Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://fanyuecheng.github.io"/>
    <link rel="self" href="https://fanyuecheng.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://fanyuecheng.github.io/images/avatar.png</logo>
    <icon>https://fanyuecheng.github.io/favicon.ico</icon>
    <rights>All rights reserved 2023, fanyuecheng&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[探索UIButtonConfiguration  ]]></title>
        <id>https://fanyuecheng.github.io/post/ios-tan-suo-uibuttonconfiguration/</id>
        <link href="https://fanyuecheng.github.io/post/ios-tan-suo-uibuttonconfiguration/">
        </link>
        <updated>2023-10-11T03:15:26.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p><strong>UIButtonConfiguration</strong>是iOS15新增的用于指定按钮及其内容的外观和行为的一种配置。<br>
可以使用它配置和更新按钮，一个按钮配置包含了其他所有可用的自定义选项方法，并且可以作为这些方法的替代。并且可以将配置与这些其他方法结合使用来定制按钮行为和外观，而无需重写自定义的UIButton代码。</p>
<h2 id="详述">详述</h2>
<ol>
<li>默认配置</li>
</ol>
<ul>
<li>plainButtonConfiguration:为具有透明背景的按钮配置</li>
<li>grayButtonConfiguration:为具有灰色背景的按钮配置</li>
<li>tintedButtonConfiguration:为具有着色背景色的按钮配置</li>
<li>filledButtonConfiguration:为其背景填充有按钮的色调的按钮配置</li>
<li>borderlessButtonConfiguration:为具有无边框样式的按钮配置</li>
<li>borderedButtonConfiguration:为具有边框样式的按钮配置</li>
<li>borderedTintedButtonConfiguration:为具有着色边框样式的按钮配置</li>
<li>borderedProminentButtonConfiguration:为具有突出边框样式的按钮配置<br>
<a href="https://imgse.com/i/pPz2jr8"><img src="https://z1.ax1x.com/2023/10/11/pPz2jr8.png" alt="pPz2jr8.png" loading="lazy"></a></li>
</ul>
<ol start="2">
<li>
<p>属性相关</p>
<p><strong>title属性</strong></p>
</li>
</ol>
<ul>
<li>
<p>title:按钮标题</p>
</li>
<li>
<p>subtitle:按钮子标题</p>
</li>
<li>
<p>attributedTitle: 按钮富文本标题</p>
</li>
<li>
<p>attributedSubtitle: 按钮富文本子标题</p>
</li>
<li>
<p>titleTextAttributesTransformer:用于按钮状态变化时更新titleTextAttributes的block</p>
</li>
<li>
<p>subtitleTextAttributesTransformer:用于按钮状态变化时更新subtitleTextAttributes的block</p>
</li>
<li>
<p>titlePadding:titleLabel和subtitleLabel的间距</p>
</li>
<li>
<p>titleAlignment:title和subtitle的对齐方式</p>
<p><strong>image属性</strong></p>
</li>
<li>
<p>image:按钮显示的图片</p>
</li>
<li>
<p>imagePadding:按钮的图像和文本的间距</p>
</li>
<li>
<p>imagePlacement:图片在按钮中的位置</p>
</li>
<li>
<p>imageColorTransformer:用于按钮状态变化时更新imageColor的block</p>
</li>
<li>
<p>preferredSymbolConfigurationForImage:按钮符号图片的配置（UIImageSymbolConfiguration）<br>
<strong>布局属性</strong></p>
</li>
<li>
<p>buttonSize:(UIButtonConfigurationSize)按钮期望大小</p>
</li>
<li>
<p>contentInsets:(NSDirectionalEdgeInsets)按钮内容的内边距</p>
</li>
<li>
<p>setDefaultContentInsets:恢复默认contentInsets<br>
<a href="https://imgse.com/i/pPzWY60"><img src="https://z1.ax1x.com/2023/10/11/pPzWY60.png" alt="pPzWY60.png" loading="lazy"></a></p>
<p><strong>颜色属性</strong></p>
</li>
<li>
<p>baseBackgroundColor</p>
</li>
<li>
<p>baseForegroundColor</p>
<p><strong>背景属性</strong></p>
</li>
<li>
<p>background:(UIBackgroundConfiguration)</p>
</li>
<li>
<p>cornerStyle:(UIButtonConfigurationCornerStyle)</p>
<p><strong>指示器属性</strong></p>
</li>
<li>
<p>indicator:(UIButtonConfigurationIndicator)</p>
</li>
<li>
<p>indicatorColorTransformer:用于按钮状态变化时更新indicatorColor的block</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用UIStackView组成常见UI样式]]></title>
        <id>https://fanyuecheng.github.io/post/shi-yong-uistackview-zu-cheng-chang-jian-ui-yang-shi/</id>
        <link href="https://fanyuecheng.github.io/post/shi-yong-uistackview-zu-cheng-chang-jian-ui-yang-shi/">
        </link>
        <updated>2022-06-16T10:24:55.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>目前有一种UI设计，简单来说就是各种小的，种类不同的子视图堆叠，常见于各大App列表中，比如外卖软件商家列表里面的各种tag堆叠，社交App个人信息里的各种tag堆叠等等。 这时候使用UIStackView往往会有事半功倍的奇效。鉴于对于UIStackView详细介绍的文章太多这里就不再过多赘述，仅写一简单使用范例。<br>
<a href="https://imgtu.com/i/XHNj1O"><img src="https://s1.ax1x.com/2022/06/16/XHNj1O.md.png" alt="XHNj1O.md.png" loading="lazy"></a></p>
<h2 id="简单使用">简单使用</h2>
<p>1.创建UIStackView，并添加需要显示的子视图。</p>
<pre><code>_stackView = [[UIStackView alloc] init];
_stackView.spacing = 5;
_stackView.axis = UILayoutConstraintAxisHorizontal;
_stackView.alignment = UIStackViewAlignmentCenter; 
[_stackView addArrangedSubview:self.nameLabel];
[_stackView addArrangedSubview:self.boutiqueView];
[_stackView addArrangedSubview:self.qualityView];
[_stackView addArrangedSubview:self.scheduleLabel];
[_stackView setCustomSpacing:2 afterView:self.boutiqueView];  
</code></pre>
<p>2.布局UIStackView<br>
使用<strong>约束</strong>给UIStackView布局，一般情况只需top,left,right即可。<br>
根据数据条件，控制子视图显隐即可。<br>
3.特别的<br>
如果子视图长度超过UIStackView，可以设置子视图的约束优先级，优先挤压某个子视图即可。</p>
<pre><code>- (void)setContentCompressionResistancePriority:(UILayoutPriority)priority forAxis:(UILayoutConstraintAxis)axis API_AVAILABLE(ios(6.0));
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Block的循环引用详解]]></title>
        <id>https://fanyuecheng.github.io/post/block-de-xun-huan-yin-yong-xiang-jie/</id>
        <link href="https://fanyuecheng.github.io/post/block-de-xun-huan-yin-yong-xiang-jie/">
        </link>
        <updated>2022-03-03T10:49:36.000Z</updated>
        <content type="html"><![CDATA[<h2 id="什么情况下block会造成循环引用">什么情况下block会造成循环引用</h2>
<p>ARC 情况下<code>block</code>为了保证代码块内部对象不被提前释放，会对<code>block</code>中的对象进行强引用，就相当于持有了其中的对象，而如果此时<code>block</code>中的对象又持有了该<code>block</code>，就会造成循环引用。</p>
<h2 id="常见误区">常见误区</h2>
<ul>
<li>所有block都会造成循环引用</li>
</ul>
<ol>
<li>UIView的block动画不会造成循环引用。类方法不能强引用一个类，所以不会造成循环引用。</li>
<li>Masonry约束block不会造成循环引用。view并没有持有该block。</li>
<li>AFN、YTKNetwork等请求回调block不会造成循环引用。因为在block执行后，主动释放了block。<br>
但是以上三种情况依然 <code>weakSelf</code>、<code>strongSelf</code>结合使用不影响。</li>
</ol>
<ul>
<li>block中只有self会造成循环引用<br>
用下划线调用属性(如_name)也会出现循环引用，效果和使用self是一样的，因为内部会用self-&gt;name去查找。</li>
<li>通过<code> __weak __typeof(self) weakSelf = self;</code> 可以解决所有block造成的循环引用<br>
大部分情况下，这样使用是可以解决block循环引用，但是有些情况下这样使用会造成一些问题，比如在block中延迟执行一些代码，在还没有执行的时候，控制器被销毁了，这样控制器中的对象也会被释放，__weak对象就会变成null。所以会输出null。<code>__strong __typeof(weakSelf)strongSelf = weakSelf;</code>可解。</li>
</ul>
<h2 id="如何避免">如何避免</h2>
<ul>
<li><code>weakSelf</code>、<code>strongSelf</code>结合使用。</li>
<li>block的外部对象使用<code>weak</code>，比如用<code>weak</code>修饰property。</li>
<li>将持有block的对象置空，或者block执行后将block置空。如：</li>
</ul>
<pre><code>self.one = [[TestObject alloc] init];
self.two = [[TestObject alloc] init]; 
self.one.blockProperty = ^{
    NSLog(@&quot;%@&quot;, _two);
};
self.one.blockProperty();
self.one.blockProperty = nil;
或者 self.one = nil;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[UINavigationbar布局]]></title>
        <id>https://fanyuecheng.github.io/post/uinavigationbar-bu-ju/</id>
        <link href="https://fanyuecheng.github.io/post/uinavigationbar-bu-ju/">
        </link>
        <updated>2021-10-12T06:46:29.000Z</updated>
        <content type="html"><![CDATA[<h3 id="设备iphone-13-pro-模拟器-ios-15">设备：iPhone 13 Pro 模拟器  iOS 15</h3>
<h4 id="默认显示">默认显示</h4>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2021/10/12/U65zIMeZh74lroE.png" alt="bar.png" loading="lazy"></figure>
<p>1.Title<br>
textAttributes:<br>
font:<code>font-family: &quot;UICTFontTextStyleShortEmphasizedBody&quot;; font-weight: bold; font-style: normal; font-size: 17.00pt </code><br>
textColor:<code>labelColor</code><br>
UI:<code>UIlabel</code></p>
<p>2.BarButtonItem<br>
font:<br>
Plain：<code>font-family: &quot;UICTFontTextStyleEmphasizedBody&quot;; font-weight: bold; font-style: normal; font-size: 17.00pt</code><br>
Done：<code>font-family: &quot;UICTFontTextStyleBody&quot;; font-weight: normal; font-style: normal; font-size: 17.00pt</code><br>
textColor:<code>systemBlueColor</code><br>
UI:<code>_UIButtonBarStackView -&gt; _UIButtonBarButton -&gt; _UIModernBarButton -&gt; UIButtonLabel</code><br>
<img src="https://i.loli.net/2021/10/12/RDrIm1lHYdaCfgA.png" alt="item.png" loading="lazy"></p>
<h4 id="默认布局">默认布局</h4>
<p>1.正常情况<br>
<img src="https://i.loli.net/2021/10/12/vUPMWoBi2gKycfT.png" alt="bar.png" loading="lazy"><br>
可通过<code>UIBarButtonItemStateAppearance </code>的<code>titlePositionAdjustment</code>属性来调整<code>_UIModernBarButton </code>的位置<br>
2.特殊情况<br>
1).仅有 LeftBarButtonItem 或 RightBarButtonItem<br>
<a href="https://imgtu.com/i/5mPOu8"><img src="https://z3.ax1x.com/2021/10/12/5mPOu8.png" alt="item.png" loading="lazy"></a><br>
<a href="https://imgtu.com/i/5miC3q"><img src="https://z3.ax1x.com/2021/10/12/5miC3q.png" alt="item.png" loading="lazy"></a><br>
2).仅有title<br>
title居中，最宽时前后8距离<br>
<a href="https://imgtu.com/i/5mki0U"><img src="https://z3.ax1x.com/2021/10/12/5mki0U.png" alt="title.png" loading="lazy"></a><br>
3).有title和item<br>
item优先级高于title，会优先显示item，并且title可能会显示不全甚至无法显示<br>
title距离item 6<br>
<a href="https://imgtu.com/i/5mivM6"><img src="https://z3.ax1x.com/2021/10/12/5mivM6.png" alt="item.png" loading="lazy"></a><br>
4).BackBarButtonItem<br>
iOS14以后可通过设置<code>navigationItem.backButtonDisplayMode</code>来控制BackBarButtonItem的显示模式。<br>
默认状态下，BackBarButtonItem显示&quot;&lt;&quot; + title<br>
title过长，则显示 &quot;&lt;&quot; + &quot;Back&quot;<br>
title超级长，则只显示 &quot;&lt;&quot;</p>
<p>5).BarButtonItems<br>
可通过设<code>UIBarButtonSystemItemFixedSpace</code>类型的item调整item之间的距离，默认8<br>
items数组，index从小到大，是从屏幕边向内侧的顺序排列，其中index为0的item后无空隙，其余有3的空隙，不知为何<br>
<a href="https://imgtu.com/i/5mUUvq"><img src="https://z3.ax1x.com/2021/10/12/5mUUvq.png" alt="items.png" loading="lazy"></a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[UIFont 各属性图解]]></title>
        <id>https://fanyuecheng.github.io/post/uifont-ge-shu-xing-tu-jie/</id>
        <link href="https://fanyuecheng.github.io/post/uifont-ge-shu-xing-tu-jie/">
        </link>
        <updated>2021-03-24T07:42:33.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://fanyuecheng.github.io/post-images/1616571842113.png" alt="" loading="lazy"></figure>
<pre><code>@property (nonatomic, readonly) CGFloat pointSize;
@property (nonatomic, readonly) CGFloat ascender;
@property (nonatomic, readonly) CGFloat descender;
@property (nonatomic, readonly) CGFloat capHeight;
@property (nonatomic, readonly) CGFloat xHeight;
@property (nonatomic, readonly) CGFloat lineHeight API_AVAILABLE(ios(4.0));
@property (nonatomic, readonly) CGFloat leading;  
</code></pre>
<h2 id="不同字号下两个font之间-垂直居中所需要baseline-offset">不同字号下两个font之间 垂直居中所需要baseline offset</h2>
<pre><code>+ (float)baselineOffsetBetweenFont:(UIFont *)font1 anotherFont:(UIFont *)font2 {
    CGFloat base1 = font1.ascender;
    CGFloat base2 = font2.ascender;
    CGFloat lh1 = font1.lineHeight;
    CGFloat lh2 = font2.lineHeight;
    CGFloat offset1 = base2 - base1;
    CGFloat offset2 = (lh2 - lh1) / 2;
    return offset1 - offset2;
}  
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[iOS原生社会化分享]]></title>
        <id>https://fanyuecheng.github.io/post/ios-yuan-sheng-she-hui-hua-fen-xiang/</id>
        <link href="https://fanyuecheng.github.io/post/ios-yuan-sheng-she-hui-hua-fen-xiang/">
        </link>
        <updated>2021-01-05T08:18:45.000Z</updated>
        <content type="html"><![CDATA[<h2 id="uiactivityviewcontroller">UIActivityViewController</h2>
<pre><code>NSString *textToShare = @&quot;分享的标题&quot;;   
UIImage *imageToShare = [UIImage imageNamed:@&quot;test.jpg&quot;];   
NSURL *urlToShare = [NSURL URLWithString:@&quot;http://www.baidu.com&quot;];  
//NSURL * urlToShare = [[NSBundle mainBundle] URLForResource:@&quot;test&quot; withExtension:@&quot;zip&quot;];  

NSArray *activityItems = @[textToShare, imageToShare, urlToShare];  
UIActivityViewController *activityVC = [[UIActivityViewController alloc]initWithActivityItems:activityItems applicationActivities:nil];  

/*
 不想显示的type
 activityVC.excludedActivityTypes = @[];
 点击的回调
 activityVC.completionWithItemsHandler = 
 */

[self presentViewController:activityVC animated:YES completion:nil];  
</code></pre>
<h2 id="social-framework">Social Framework</h2>
<pre><code>#import &lt;Social/Social.h&gt;  

SLComposeViewController *composeVc = [SLComposeViewController composeViewControllerForServiceType:SLServiceTypeSinaWeibo];  

if (composeVc == nil){  
    NSLog(@&quot;未安装软件&quot;);  
    return;  
}  

if (![SLComposeViewController isAvailableForServiceType:SLServiceTypeSinaWeibo]) {  
    NSLog(@&quot;软件未配置登录信息&quot;);  
    return;  
}  

//添加分享的文字、图片、链接  
[composeVc setInitialText:@&quot;要分享的文本内容&quot;];  
[composeVc addImage:[UIImage imageNamed:@&quot;choice_highlight&quot;]];  
[composeVc addURL:[NSURL URLWithString:@&quot;http://www.baidu.com&quot;]];  
[self presentViewController:composeVc animated:YES completion:nil];  
//监听用户点击了取消还是发送  

composeVc.completionHandler = ^(SLComposeViewControllerResult result){

    if (result == SLComposeViewControllerResultCancelled) {

    } else {
    
    }
};
</code></pre>
<p>系统只提供了下面几种分享平台：</p>
<pre><code>SLServiceTypeTwitter;  
SLServiceTypeFacebook;  
SLServiceTypeSinaWeibo;  
SLServiceTypeTencentWeibo;  
SLServiceTypeLinkedIn;
</code></pre>
<p>实际可以根据id来分享到更多平台，如微信:</p>
<pre><code>NSString *socialType = @&quot;com.tencent.xin.sharetimeline&quot;;  
SLComposeViewController *composeVC = [SLComposeViewController composeViewControllerForServiceType:socialType];
</code></pre>
<p>可以这么使用的原因是:iOS8之后系统推出的Share Extension,不是系统实现了微信分享，而是微信App的Share Extension提供了分享入口。所以这个不是私有API，可以放心使用，想获取手机中装的App的所有Share Extension的方法。只需调用下面一句代码。</p>
<pre><code>SLComposeViewController *composeVc = [SLComposeViewController composeViewControllerForServiceType:SLServiceTypeSinaWeibo];
</code></pre>
<p>看看控制台输出，手机内所有可用的Share Extension的bundle Id 都出来了。<br>
<img src="https://i.loli.net/2020/01/08/TOh7p4qzlMokFxV.png" alt="img" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[我看NSOperation和NSOperationQueue]]></title>
        <id>https://fanyuecheng.github.io/post/wo-kan-nsoperation-he-nsoperationqueue/</id>
        <link href="https://fanyuecheng.github.io/post/wo-kan-nsoperation-he-nsoperationqueue/">
        </link>
        <updated>2021-01-05T08:14:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="nsoperation-nsoperationqueue-简介">NSOperation、NSOperationQueue 简介</h2>
<p>NSOperation、NSOperationQueue 是苹果提供给我们的一套多线程解决方案。<br>
本质上NSOperation、NSOperationQueue是基于GCD更高一层的封装，完全面向对象。但是比GCD更简单易用、代码可读性也更高。</p>
<p>为什么要使用 NSOperation、NSOperationQueue？<br>
可添加完成的代码块，在操作完成后执行。<br>
添加操作之间的依赖关系，方便的控制执行顺序。<br>
设定操作执行的优先级。<br>
可以很方便的取消一个操作的执行。<br>
使用 KVO 观察对操作执行状态的更改：isExecuteing、isFinished、isCancelled。</p>
<h2 id="nsoperation-nsoperationqueue-操作和操作队列">NSOperation、NSOperationQueue 操作和操作队列</h2>
<p>既然是基于GCD的更高一层的封装，那么GCD中的一些概念同样适用于 NSOperation、NSOperationQueue。在NSOperation、NSOperationQueue中也有类似的任务（操作）和队列（操作队列）的概念。</p>
<p>操作（Operation）：<br>
执行操作的意思，换句话说就是你在线程中执行的那段代码。<br>
在 GCD 中是放在 block 中的。在 NSOperation 中，我们使用 NSOperation 子类 NSInvocationOperation、NSBlockOperation，或者自定义子类来封装操作。<br>
操作队列（Operation Queues）：<br>
这里的队列指操作队列，即用来存放操作的队列。不同于 GCD 中的调度队列 FIFO（先进先出）的原则。NSOperationQueue 对于添加到队列中的操作，首先进入准备就绪的状态（就绪状态取决于操作之间的依赖关系），然后进入就绪状态的操作的开始执行顺序（非结束执行顺序）由操作之间相对的优先级决定（优先级是操作对象自身的属性）。<br>
操作队列通过设置最大并发操作数（maxConcurrentOperationCount）来控制并发、串行。<br>
NSOperationQueue 为我们提供了两种不同类型的队列：主队列和自定义队列。主队列运行在主线程之上，而自定义队列在后台执行。</p>
<h2 id="nsoperation-nsoperationqueue-使用步骤">NSOperation、NSOperationQueue 使用步骤</h2>
<p>NSOperation 需要配合 NSOperationQueue 来实现多线程。因为默认情况下，NSOperation 单独使用时系统同步执行操作，配合 NSOperationQueue 我们能更好的实现异步执行。</p>
<p>NSOperation 实现多线程的使用步骤分为三步：</p>
<p>创建操作：先将需要执行的操作封装到一个 NSOperation 对象中。<br>
创建队列：创建 NSOperationQueue 对象。<br>
将操作加入到队列中：将 NSOperation 对象添加到 NSOperationQueue 对象中。<br>
之后系统就会自动将 NSOperationQueue 中的 NSOperation 取出来，在新线程中执行操作。</p>
<h2 id="nsoperation-和-nsoperationqueue-基本使用">NSOperation 和 NSOperationQueue 基本使用</h2>
<p>NSOperation 是个抽象类，不能用来封装操作。我们只有使用它的子类来封装操作。我们有三种方式来封装操作。</p>
<p>使用子类 NSInvocationOperation<br>
使用子类 NSBlockOperation<br>
自定义继承自 NSOperation 的子类，通过实现内部相应的方法来封装操作。<br>
在不使用 NSOperationQueue，单独使用 NSOperation 的情况下系统同步执行操作，下面我们学习以下操作的三种创建方式。</p>
<p>使用子类 NSInvocationOperation</p>
<pre><code>- (void)useInvocationOperation {
   NSInvocationOperation *op = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(task) object:nil];
   [op start];
}

- (void)task {
   for (int i = 0; i &lt; 2; i++) {
   	[NSThread sleepForTimeInterval:2]; 
      NSLog(@&quot;Thread : %@&quot;, [NSThread currentThread]); 
   }
}  
</code></pre>
<p>输出结果：</p>
<pre><code>2019-12-02 18:10:42.765469+0800 YCTest[2971:74174] Thread : &lt;NSThread: 0x600000196c40&gt;{number = 1, name = main}
2019-12-02 18:10:44.767111+0800 YCTest[2971:74174] Thread : &lt;NSThread: 0x600000196c40&gt;{number = 1, name = main}
</code></pre>
<p>可以看到：在没有使用 NSOperationQueue，在主线程中单独使用使用子类 NSInvocationOperation 执行一个操作的情况下，操作是在当前线程执行的，并没有开启新线程。<br>
如果在其他线程中执行操作，则打印结果为其他线程。</p>
<p>结论：在其他线程中单独使用子类 NSInvocationOperation，操作是在当前调用的其他线程执行的，并没有开启新线程。</p>
<p>使用子类 NSBlockOperation</p>
<pre><code>- (void)useBlockOperation {
    NSBlockOperation *op = [NSBlockOperation blockOperationWithBlock:^{
        for (int i = 0; i &lt; 2; i++) {
         	 [NSThread sleepForTimeInterval:2]; 
           NSLog(@&quot;Thread : %@&quot;, [NSThread currentThread]);        
        }
    }];
    [op start];
}  
</code></pre>
<p>输出结果：</p>
<pre><code>2019-12-02 18:15:20.386650+0800 YCTest[3014:76923] Thread : &lt;NSThread: 0x6000013521c0&gt;{number = 1, name = main}
2019-12-02 18:15:22.387041+0800 YCTest[3014:76923] Thread : &lt;NSThread: 0x6000013521c0&gt;{number = 1, name = main}
</code></pre>
<p>可以看到：在没有使用 NSOperationQueue、在主线程中单独使用 NSBlockOperation 执行一个操作的情况下，操作是在当前线程执行的，并没有开启新线程。<br>
注意：和上边 NSInvocationOperation 使用一样。因为代码是在主线程中调用的，所以打印结果为主线程。如果在其他线程中执行操作，则打印结果为其他线程。</p>
<p>但是，NSBlockOperation 还提供了一个方法addExecutionBlock:，通过 addExecutionBlock:就可以为 NSBlockOperation 添加额外的操作。这些操作（包括 blockOperationWithBlock 中的操作）可以在不同的线程中同时（并发）执行。只有当所有相关的操作已经完成执行时，才视为完成。</p>
<p>如果添加的操作多的话，blockOperationWithBlock: 中的操作也可能会在其他线程（非当前线程）中执行，这是由系统决定的，并不是说添加到 blockOperationWithBlock: 中的操作一定会在当前线程中执行。（可以使用 addExecutionBlock: 多添加几个操作试试）。</p>
<pre><code>- (void)useBlockOperationAddExecutionBlock {
    NSBlockOperation *op = [NSBlockOperation blockOperationWithBlock:^{
        for (int i = 0; i &lt; 2; i++) {
			[NSThread sleepForTimeInterval:2];        
			NSLog(@&quot;NSThread : %@&quot;, [NSThread currentThread]); 
        }
    }];

    [op addExecutionBlock:^{
        for (int i = 0; i &lt; 2; i++) {
            [NSThread sleepForTimeInterval:2];  
            NSLog(@&quot;NSThread 2 : %@&quot;, [NSThread currentThread]);  
        }
    }];
    
    [op addExecutionBlock:^{
        for (int i = 0; i &lt; 2; i++) {
           [NSThread sleepForTimeInterval:2];              			  NSLog(@&quot;NSThread 3 : %@&quot;, [NSThread currentThread]);  
        }
    }];
    
    [op addExecutionBlock:^{
        for (int i = 0; i &lt; 2; i++) {
            [NSThread sleepForTimeInterval:2];  
            NSLog(@&quot;NSThread 4 : %@&quot;, [NSThread currentThread]); 
        }
    }];
    
    [op addExecutionBlock:^{
        for (int i = 0; i &lt; 2; i++) {
            [NSThread sleepForTimeInterval:2];  
            NSLog(@&quot;NSThread 5 : %@&quot;, [NSThread currentThread]);
        }
    }];
    
    [op addExecutionBlock:^{
        for (int i = 0; i &lt; 2; i++) {
            [NSThread sleepForTimeInterval:2]; 
            NSLog(@&quot;NSThread 6 : %@&quot;, [NSThread currentThread]);
        }
    }];

    [op start];
}  
</code></pre>
<p>输出结果：</p>
<pre><code>2019-12-02 18:21:18.318167+0800 YCTest[3046:79921] NSThread 4 : &lt;NSThread: 0x6000039d8400&gt;{number = 5, name = (null)}
2019-12-02 18:21:18.318181+0800 YCTest[3046:79926] NSThread 3 : &lt;NSThread: 0x6000039d2f40&gt;{number = 8, name = (null)}
2019-12-02 18:21:18.318189+0800 YCTest[3046:79794] NSThread : &lt;NSThread: 0x6000039821c0&gt;{number = 1, name = main}
2019-12-02 18:21:18.318189+0800 YCTest[3046:79915] NSThread 2 : &lt;NSThread: 0x6000039f9700&gt;{number = 9, name = (null)}
2019-12-02 18:21:20.319627+0800 YCTest[3046:79915] NSThread 2 : &lt;NSThread: 0x6000039f9700&gt;{number = 9, name = (null)}
2019-12-02 18:21:20.319627+0800 YCTest[3046:79794] NSThread : &lt;NSThread: 0x6000039821c0&gt;{number = 1, name = main}
2019-12-02 18:21:20.319627+0800 YCTest[3046:79926] NSThread 3 : &lt;NSThread: 0x6000039d2f40&gt;{number = 8, name = (null)}
2019-12-02 18:21:20.319627+0800 YCTest[3046:79921] NSThread 4 : &lt;NSThread: 0x6000039d8400&gt;{number = 5, name = (null)}
2019-12-02 18:21:22.321249+0800 YCTest[3046:79915] NSThread 6 : &lt;NSThread: 0x6000039f9700&gt;{number = 9, name = (null)}
2019-12-02 18:21:22.321251+0800 YCTest[3046:79794] NSThread 5 : &lt;NSThread: 0x6000039821c0&gt;{number = 1, name = main}
2019-12-02 18:21:24.321687+0800 YCTest[3046:79794] NSThread 5 : &lt;NSThread: 0x6000039821c0&gt;{number = 1, name = main}
2019-12-02 18:21:24.321687+0800 YCTest[3046:79915] NSThread 6 : &lt;NSThread: 0x6000039f9700&gt;{number = 9, name = (null)}
</code></pre>
<p>可以看出：使用子类 NSBlockOperation，并调用方法AddExecutionBlock:的情况下，blockOperationWithBlock:方法中的操作 和 addExecutionBlock: 中的操作是在不同的线程中异步执行的。而且，这次执行结果中 blockOperationWithBlock:方法中的操作也不是在当前线程（主线程）中执行的。从而印证了blockOperationWithBlock: 中的操作也可能会在其他线程（非当前线程）中执行。</p>
<p>一般情况下，如果一个 NSBlockOperation 对象封装了多个操作。NSBlockOperation 是否开启新线程，取决于操作的个数。如果添加的操作的个数多，就会自动开启新线程。当然开启的线程数是由系统来决定的。</p>
<p>使用自定义继承自 NSOperation 的子类</p>
<p>如果使用子类 NSInvocationOperation、NSBlockOperation 不能满足日常需求，我们可以使用自定义继承自 NSOperation 的子类。可以通过重写 main 或者 start 方法 来定义自己的 NSOperation 对象。重写main方法比较简单，我们不需要管理操作的状态属性 isExecuting 和 isFinished。当 main 执行完返回的时候，这个操作就结束了。</p>
<p>定义一个继承自 NSOperation 的子类 YCOperation，重写main方法。</p>
<pre><code>@interface YCOperation : NSOperation

@end
 
@implementation YCOperation

- (void)main {
    if (!self.isCancelled) {
        for (int i = 0; i &lt; 2; i++) {
            [NSThread sleepForTimeInterval:2];
            NSLog(@&quot;NSThread : %@&quot;, [NSThread currentThread]);
        }
    }
}

@end

- (void)useCustomOperation {
    YCOperation *op = [[YCOperation alloc] init];
    [op start];
}
</code></pre>
<p>输出结果：</p>
<pre><code>2019-12-02 18:25:33.319039+0800 YCTest[3080:82116] NSThread : &lt;NSThread: 0x600002236300&gt;{number = 1, name = main}
2019-12-02 18:25:35.320127+0800 YCTest[3080:82116] NSThread : &lt;NSThread: 0x600002236300&gt;{number = 1, name = main}
</code></pre>
<p>可以看出：在没有使用 NSOperationQueue、在主线程单独使用自定义继承自 NSOperation 的子类的情况下，是在主线程执行操作，并没有开启新线程。</p>
<p>创建队列<br>
NSOperationQueue 一共有两种队列：主队列、自定义队列。<br>
其中自定义队列同时包含了串行、并发功能。</p>
<p>主队列<br>
凡是添加到主队列中的操作，都会放到主线程中执行（注：不包括操作使用addExecutionBlock:添加的额外操作，额外操作可能在其他线程执行，感谢指正）。</p>
<p>主队列获取方法</p>
<pre><code>[NSOperationQueue mainQueue]
</code></pre>
<p>自定义队列（非主队列）<br>
添加到这种队列中的操作，就会自动放到子线程中执行。<br>
同时包含了：串行、并发功能。</p>
<p>自定义队列创建方法</p>
<pre><code>[[NSOperationQueue alloc] init]
</code></pre>
<p>将操作加入到队列中</p>
<p>上边我们说到 NSOperation 需要配合 NSOperationQueue 来实现多线程。<br>
那么我们需要将创建好的操作加入到队列中去。总共有两种方法：</p>
<p>addOperation</p>
<pre><code>- (void)addOperationToQueue {
    NSOperationQueue *queue = [[NSOperationQueue alloc] init];

    NSInvocationOperation *op1 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(task1) object:nil];
    NSInvocationOperation *op2 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(task2) object:nil];
    NSBlockOperation *op3 = [NSBlockOperation blockOperationWithBlock:^{
        for (int i = 0; i &lt; 2; i++) {
            [NSThread sleepForTimeInterval:2];  
            NSLog(@&quot;Thread 3 : %@&quot;, [NSThread currentThread]);
        }
    }];
    [op3 addExecutionBlock:^{
        for (int i = 0; i &lt; 2; i++) {
            [NSThread sleepForTimeInterval:2];  
            NSLog(@&quot;Thread 4 : %@&quot;, [NSThread currentThread]);
        }
    }];

    [queue addOperation:op1];  
    [queue addOperation:op2];  
    [queue addOperation:op3]; 
}
</code></pre>
<p>输出结果：</p>
<pre><code>2019-12-02 18:33:22.796673+0800 YCTest[3149:86613] Thread 4 : &lt;NSThread: 0x6000034f5400&gt;{number = 4, name = (null)}
2019-12-02 18:33:22.796751+0800 YCTest[3149:86621] Thread 1 : &lt;NSThread: 0x6000034fd840&gt;{number = 3, name = (null)}
2019-12-02 18:33:22.796766+0800 YCTest[3149:86620] Thread 2 : &lt;NSThread: 0x600003429140&gt;{number = 9, name = (null)}
2019-12-02 18:33:22.796770+0800 YCTest[3149:86618] Thread 3 : &lt;NSThread: 0x600003421180&gt;{number = 10, name = (null)}
2019-12-02 18:33:24.797507+0800 YCTest[3149:86620] Thread 2 : &lt;NSThread: 0x600003429140&gt;{number = 9, name = (null)}
2019-12-02 18:33:24.797494+0800 YCTest[3149:86618] Thread 3 : &lt;NSThread: 0x600003421180&gt;{number = 10, name = (null)}
2019-12-02 18:33:24.797495+0800 YCTest[3149:86613] Thread 4 : &lt;NSThread: 0x6000034f5400&gt;{number = 4, name = (null)}
2019-12-02 18:33:24.797569+0800 YCTest[3149:86621] Thread 1 : &lt;NSThread: 0x6000034fd840&gt;{number = 3, name = (null)}
</code></pre>
<p>可以看出：使用 NSOperation 子类创建操作，并使用 addOperation: 将操作加入到操作队列后能够开启新线程，进行并发执行。</p>
<p>addOperationWithBlock<br>
无需先创建操作，在 block 中添加操作，直接将包含操作的 block 加入到队列。</p>
<pre><code>- (void)addOperationWithBlockToQueue {
    NSOperationQueue *queue = [[NSOperationQueue alloc] init];
    [queue addOperationWithBlock:^{
        for (int i = 0; i &lt; 2; i++) {
            [NSThread sleepForTimeInterval:2];  
            NSLog(@&quot;Thread 1 : %@&quot;, [NSThread currentThread]);  
        }
    }];
    [queue addOperationWithBlock:^{
        for (int i = 0; i &lt; 2; i++) {
            [NSThread sleepForTimeInterval:2]; 
            NSLog(@&quot;Thread 2 : %@&quot;, [NSThread currentThread]);    
        }
    }];
    [queue addOperationWithBlock:^{
        for (int i = 0; i &lt; 2; i++) {
            [NSThread sleepForTimeInterval:2];  
            NSLog(@&quot;Thread 3 : %@&quot;, [NSThread currentThread]);  
        }
    }];
}  
</code></pre>
<p>输出结果：</p>
<pre><code>2019-12-02 18:37:23.028767+0800 YCTest[3178:88816] Thread 1 : &lt;NSThread: 0x600000cbaac0&gt;{number = 5, name = (null)}
2019-12-02 18:37:23.028767+0800 YCTest[3178:88819] Thread 3 : &lt;NSThread: 0x600000c6de00&gt;{number = 8, name = (null)}
2019-12-02 18:37:23.028798+0800 YCTest[3178:88813] Thread 2 : &lt;NSThread: 0x600000c66080&gt;{number = 9, name = (null)}
2019-12-02 18:37:25.030463+0800 YCTest[3178:88813] Thread 2 : &lt;NSThread: 0x600000c66080&gt;{number = 9, name = (null)}
2019-12-02 18:37:25.030463+0800 YCTest[3178:88816] Thread 1 : &lt;NSThread: 0x600000cbaac0&gt;{number = 5, name = (null)}
2019-12-02 18:37:25.030463+0800 YCTest[3178:88819] Thread 3 : &lt;NSThread: 0x600000c6de00&gt;{number = 8, name = (null)}
</code></pre>
<p>可以看出：使用 addOperationWithBlock: 将操作加入到操作队列后能够开启新线程，进行并发执行。</p>
<h2 id="nsoperationqueue-控制串行执行-并发执行">NSOperationQueue 控制串行执行、并发执行</h2>
<p>之前我们说过，NSOperationQueue 创建的自定义队列同时具有串行、并发功能，上边我们演示了并发功能，那么他的串行功能是如何实现的？</p>
<p>这里有个关键属性 maxConcurrentOperationCount，叫做最大并发操作数。用来控制一个特定队列中可以有多少个操作同时参与并发执行。</p>
<p>注意：这里 maxConcurrentOperationCount 控制的不是并发线程的数量，而是一个队列中同时能并发执行的最大操作数。而且一个操作也并非只能在一个线程中运行。</p>
<p>最大并发操作数：maxConcurrentOperationCount<br>
maxConcurrentOperationCount 默认情况下为-1，表示不进行限制，可进行并发执行。<br>
maxConcurrentOperationCount 为1时，队列为串行队列。只能串行执行。<br>
maxConcurrentOperationCount 大于1时，队列为并发队列。操作并发执行，当这个值不应超过系统限制，即使自己设置一个很大的值，系统也会自动调整为 min{自己设定的值，系统设定的默认最大值}。</p>
<pre><code>- (void)setMaxConcurrentOperationCount {
    NSOperationQueue *queue = [[NSOperationQueue alloc] init];
    queue.maxConcurrentOperationCount = 2;  
    [queue addOperationWithBlock:^{
        for (int i = 0; i &lt; 2; i++) {
            [NSThread sleepForTimeInterval:2];  
            NSLog(@&quot;Thread 1 : %@&quot;, [NSThread currentThread]);
        }
    }];
    [queue addOperationWithBlock:^{
        for (int i = 0; i &lt; 2; i++) {
            [NSThread sleepForTimeInterval:2]; 
            NSLog(@&quot;Thread 2 : %@&quot;, [NSThread currentThread]);
        }
    }];
}  
</code></pre>
<p>最大并发操作数为1 输出结果：</p>
<pre><code>2019-12-02 18:40:50.455893+0800 YCTest[3209:90870] Thread 1 : &lt;NSThread: 0x6000001a7580&gt;{number = 8, name = (null)}
2019-12-02 18:40:52.456843+0800 YCTest[3209:90870] Thread 1 : &lt;NSThread: 0x6000001a7580&gt;{number = 8, name = (null)}
2019-12-02 18:40:54.461261+0800 YCTest[3209:90866] Thread 2 : &lt;NSThread: 0x60000015b800&gt;{number = 9, name = (null)}
2019-12-02 18:40:56.464548+0800 YCTest[3209:90866] Thread 2 : &lt;NSThread: 0x60000015b800&gt;{number = 9, name = (null)}  
</code></pre>
<p>最大并发操作数为2 输出结果：</p>
<pre><code>2019-12-02 18:41:38.299277+0800 YCTest[3227:91679] Thread 1 : &lt;NSThread: 0x60000171bc80&gt;{number = 5, name = (null)}
2019-12-02 18:41:38.299281+0800 YCTest[3227:91670] Thread 2 : &lt;NSThread: 0x60000171e740&gt;{number = 4, name = (null)}
2019-12-02 18:41:40.299803+0800 YCTest[3227:91670] Thread 2 : &lt;NSThread: 0x60000171e740&gt;{number = 4, name = (null)}
2019-12-02 18:41:40.299804+0800 YCTest[3227:91679] Thread 1 : &lt;NSThread: 0x60000171bc80&gt;{number = 5, name = (null)}
</code></pre>
<p>可以看出：当最大并发操作数为1时，操作是按顺序串行执行的，并且一个操作完成之后，下一个操作才开始执行。<br>
当最大操作并发数为2时，操作是并发执行的，可以同时执行两个操作。而开启线程数量是由系统决定的，不需要我们来管理。</p>
<h2 id="nsoperation-操作依赖">NSOperation 操作依赖</h2>
<p>NSOperation、NSOperationQueue 最吸引人的地方是它能添加操作之间的依赖关系。通过操作依赖，我们可以很方便的控制操作之间的执行先后顺序。NSOperation 提供了3个接口供我们管理和查看依赖。</p>
<pre><code>- (void)addDependency:(NSOperation *)op; 添加依赖，使当前操作依赖于操作 op 的完成。
- (void)removeDependency:(NSOperation *)op; 移除依赖，取消当前操作对操作 op 的依赖。
@property (readonly, copy) NSArray&lt;NSOperation *&gt; *dependencies;
</code></pre>
<p>在当前操作开始执行之前完成执行的所有操作对象数组。<br>
当然，我们经常用到的还是添加依赖操作。现在考虑这样的需求，比如说有 A、B 两个操作，其中 A 执行完操作，B 才能执行操作。<br>
如果使用依赖来处理的话，那么就需要让操作 B 依赖于操作 A。具体代码如下：</p>
<pre><code>- (void)addDependency {
    NSOperationQueue *queue = [[NSOperationQueue alloc] init];
    NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^{
        for (int i = 0; i &lt; 2; i++) {
            [NSThread sleepForTimeInterval:2];  
            NSLog(@&quot;Thread 1 : %@&quot;, [NSThread currentThread]); 
        }
    }];
    NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^{
        for (int i = 0; i &lt; 2; i++) {
            [NSThread sleepForTimeInterval:2]; 
            NSLog(@&quot;Thread 2 : %@&quot;, [NSThread currentThread]); 
        }
    }];

    // 添加依赖 先执行op1，再执行op2
    [op2 addDependency:op1];  
    [queue addOperation:op1];
    [queue addOperation:op2];
}  
</code></pre>
<p>输出结果：</p>
<pre><code>2019-12-02 18:45:29.981743+0800 YCTest[3254:93774] Thread 1 : &lt;NSThread: 0x600000d58340&gt;{number = 4, name = (null)}
2019-12-02 18:45:31.986099+0800 YCTest[3254:93774] Thread 1 : &lt;NSThread: 0x600000d58340&gt;{number = 4, name = (null)}
2019-12-02 18:45:33.989763+0800 YCTest[3254:93774] Thread 2 : &lt;NSThread: 0x600000d58340&gt;{number = 4, name = (null)}
2019-12-02 18:45:35.992869+0800 YCTest[3254:93774] Thread 2 : &lt;NSThread: 0x600000d58340&gt;{number = 4, name = (null)}
</code></pre>
<p>可以看到：通过添加操作依赖，无论运行几次，其结果都是 op1 先执行，op2 后执行。</p>
<h2 id="nsoperation-优先级">NSOperation 优先级</h2>
<p>NSOperation 提供了queuePriority（优先级）属性，queuePriority属性适用于同一操作队列中的操作，不适用于不同操作队列中的操作。默认情况下，所有新创建的操作对象优先级都是NSOperationQueuePriorityNormal。但是我们可以通过setQueuePriority:方法来改变当前操作在同一队列中的执行优先级。</p>
<p>优先级的取值</p>
<pre><code>typedef NS_ENUM(NSInteger, NSOperationQueuePriority) {
    NSOperationQueuePriorityVeryLow = -8L,
    NSOperationQueuePriorityLow = -4L,
    NSOperationQueuePriorityNormal = 0,
    NSOperationQueuePriorityHigh = 4,
    NSOperationQueuePriorityVeryHigh = 8
};
</code></pre>
<p>上边我们说过：对于添加到队列中的操作，首先进入准备就绪的状态（就绪状态取决于操作之间的依赖关系），然后进入就绪状态的操作的开始执行顺序（非结束执行顺序）由操作之间相对的优先级决定（优先级是操作对象自身的属性）。</p>
<p>那么，什么样的操作才是进入就绪状态的操作呢？</p>
<p>当一个操作的所有依赖都已经完成时，操作对象通常会进入准备就绪状态，等待执行。<br>
举个例子，现在有4个优先级都是 NSOperationQueuePriorityNormal（默认级别）的操作：op1，op2，op3，op4。其中 op3 依赖于 op2，op2 依赖于 op1，即 op3 -&gt; op2 -&gt; op1。现在将这4个操作添加到队列中并发执行。</p>
<p>因为 op1 和 op4 都没有需要依赖的操作，所以在 op1，op4 执行之前，就是处于准备就绪状态的操作。<br>
而 op3 和 op2 都有依赖的操作（op3 依赖于 op2，op2 依赖于 op1），所以 op3 和 op2 都不是准备就绪状态下的操作。<br>
理解了进入就绪状态的操作，那么我们就理解了queuePriority 属性的作用对象。</p>
<p>queuePriority 属性决定了进入准备就绪状态下的操作之间的开始执行顺序。并且，优先级不能取代依赖关系。</p>
<p>如果一个队列中既包含高优先级操作，又包含低优先级操作，并且两个操作都已经准备就绪，那么队列先执行高优先级操作。比如上例中，如果 op1 和 op4 是不同优先级的操作，那么就会先执行优先级高的操作。</p>
<p>如果，一个队列中既包含了准备就绪状态的操作，又包含了未准备就绪的操作，未准备就绪的操作优先级比准备就绪的操作优先级高。那么，虽然准备就绪的操作优先级低，也会优先执行。优先级不能取代依赖关系。如果要控制操作间的启动顺序，则必须使用依赖关系。</p>
<h2 id="nsoperation-nsoperationqueue-线程间的通信">NSOperation、NSOperationQueue 线程间的通信</h2>
<p>在 iOS 开发过程中，我们一般在主线程里边进行 UI 刷新，例如：点击、滚动、拖拽等事件。我们通常把一些耗时的操作放在其他线程，比如说图片下载、文件上传等耗时操作。而当我们有时候在其他线程完成了耗时操作时，需要回到主线程，那么就用到了线程之间的通讯。</p>
<p>线程间通信</p>
<pre><code>- (void)communication {
    NSOperationQueue *queue = [[NSOperationQueue alloc]init];
    [queue addOperationWithBlock:^{
        // 异步进行耗时操作
        for (int i = 0; i &lt; 2; i++) {
            [NSThread sleepForTimeInterval:2]; 
            NSLog(@&quot;Thread 1 : %@&quot;, [NSThread currentThread]);
        }


        [[NSOperationQueue mainQueue] addOperationWithBlock:^{
            for (int i = 0; i &lt; 2; i++) {
                [NSThread sleepForTimeInterval:2]; 
                NSLog(@&quot;Thread 1%@&quot;, [NSThread currentThread]); 
            }
        }];
    }];
}
</code></pre>
<p>可以看到：通过线程间的通信，先在其他线程中执行操作，等操作执行完了之后再回到主线程执行主线程的相应操作。</p>
<h2 id="nsoperation-nsoperationqueue-线程同步和线程安全">NSOperation、NSOperationQueue 线程同步和线程安全</h2>
<p>线程安全：如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。<br>
若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作（更改变量），一般都需要考虑线程同步，否则的话就可能影响线程安全。</p>
<p>线程同步：可理解为线程 A 和 线程 B 一块配合，A 执行到一定程度时要依靠线程 B 的某个结果，于是停下来，示意 B 运行；B 依言执行，再将结果给 A；A 再继续操作。</p>
<p>举个简单例子就是：两个人在一起聊天。两个人不能同时说话，避免听不清(操作冲突)。等一个人说完(一个线程结束操作)，另一个再说(另一个线程再开始操作)。</p>
<p>下面，我们模拟火车票售卖的方式，实现 NSOperation 线程安全和解决线程同步问题。</p>
<p>场景：总共有50张火车票，有两个售卖火车票的窗口，一个是北京火车票售卖窗口，另一个是上海火车票售卖窗口。两个窗口同时售卖火车票，卖完为止。</p>
<p>NSOperation、NSOperationQueue 非线程安全<br>
先来看看不考虑线程安全的代码：</p>
<pre><code>
- (void)initTicketStatusNotSave {
    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  

    self.ticketSurplusCount = 50;

    // 1.创建 queue1,queue1 代表北京火车票售卖窗口
    NSOperationQueue *queue1 = [[NSOperationQueue alloc] init];
    queue1.maxConcurrentOperationCount = 1;

    // 2.创建 queue2,queue2 代表上海火车票售卖窗口
    NSOperationQueue *queue2 = [[NSOperationQueue alloc] init];
    queue2.maxConcurrentOperationCount = 1;

    // 3.创建卖票操作 op1
    NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^{
        [self saleTicketNotSafe];
    }];

    // 4.创建卖票操作 op2
    NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^{
        [self saleTicketNotSafe];
    }];

    // 5.添加操作，开始卖票
    [queue1 addOperation:op1];
    [queue2 addOperation:op2];
}  

- (void)saleTicketNotSafe {
    while (1) {
        if (self.ticketSurplusCount &gt; 0) {
            //如果还有票，继续售卖
            self.ticketSurplusCount--;
            NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;剩余票数:%d 窗口:%@&quot;, self.ticketSurplusCount, [NSThread currentThread]]);
            [NSThread sleepForTimeInterval:0.2];
        } else {
            NSLog(@&quot;所有火车票均已售完&quot;);
            break;
        }
    }
}
</code></pre>
<p>可以看到：在不考虑线程安全，不使用 NSLock 情况下，得到票数是错乱的，这样显然不符合我们的需求，所以我们需要考虑线程安全问题。</p>
<p>NSOperation、NSOperationQueue 线程安全<br>
线程安全解决方案：可以给线程加锁，在一个线程执行该操作的时候，不允许其他线程进行操作。<br>
iOS 实现线程加锁有很多种方式。@synchronized、 NSLock、NSRecursiveLock、NSCondition、NSConditionLock、pthread_mutex、dispatch_semaphore、OSSpinLock、atomic(property) set/ge等等各种方式。<br>
这里我们使用 NSLock 对象来解决线程同步问题。NSLock 对象可以通过进入锁时调用 lock 方法，解锁时调用 unlock 方法来保证线程安全。</p>
<pre><code>- (void)initTicketStatusSave {
    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  
    self.ticketSurplusCount = 50;

    self.lock = [[NSLock alloc] init];  // 初始化 NSLock 对象

    // 1.创建 queue1,queue1 代表北京火车票售卖窗口
    NSOperationQueue *queue1 = [[NSOperationQueue alloc] init];
    queue1.maxConcurrentOperationCount = 1;

    // 2.创建 queue2,queue2 代表上海火车票售卖窗口
    NSOperationQueue *queue2 = [[NSOperationQueue alloc] init];
    queue2.maxConcurrentOperationCount = 1;

    // 3.创建卖票操作 op1
    NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^{
        [self saleTicketSafe];
    }];

    // 4.创建卖票操作 op2
    NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^{
        [self saleTicketSafe];
    }];

    // 5.添加操作，开始卖票
    [queue1 addOperation:op1];
    [queue2 addOperation:op2];
}

- (void)saleTicketSafe {
    while (1) {
        // 加锁
        [self.lock lock];

        if (self.ticketSurplusCount &gt; 0) {
            //如果还有票，继续售卖
            self.ticketSurplusCount--;
            NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;剩余票数:%d 窗口:%@&quot;, self.ticketSurplusCount, [NSThread currentThread]]);
            [NSThread sleepForTimeInterval:0.2];
        }

        // 解锁
        [self.lock unlock];

        if (self.ticketSurplusCount &lt;= 0) {
            NSLog(@&quot;所有火车票均已售完&quot;);
            break;
        }
    }
}
</code></pre>
<p>可以看出：在考虑了线程安全，使用 NSLock 加锁、解锁机制的情况下，得到的票数是正确的，没有出现混乱的情况。我们也就解决了多个线程同步的问题。</p>
<h2 id="nsoperation-nsoperationqueue-常用属性和方法归纳">NSOperation、NSOperationQueue 常用属性和方法归纳</h2>
<p>NSOperation 常用属性和方法</p>
<pre><code>取消操作方法
- (void)cancel; 可取消操作，实质是标记 isCancelled 状态。
判断操作状态方法
- (BOOL)isFinished; 判断操作是否已经结束。
- (BOOL)isCancelled; 判断操作是否已经标记为取消。
- (BOOL)isExecuting; 判断操作是否正在在运行。
- (BOOL)isReady; 判断操作是否处于准备就绪状态，这个值和操作的依赖关系相关。
操作同步
- (void)waitUntilFinished; 阻塞当前线程，直到该操作结束。可用于线程执行顺序的同步。
- (void)setCompletionBlock:(void (^)(void))block; completionBlock 会在当前操作执行完毕时执行 completionBlock。
- (void)addDependency:(NSOperation *)op; 添加依赖，使当前操作依赖于操作 op 的完成。
- (void)removeDependency:(NSOperation *)op; 移除依赖，取消当前操作对操作 op 的依赖。
@property (readonly, copy) NSArray&lt;NSOperation *&gt; *dependencies; 在当前操作开始执行之前完成执行的所有操作对象数组。
</code></pre>
<p>NSOperationQueue 常用属性和方法</p>
<pre><code>取消/暂停/恢复操作
- (void)cancelAllOperations; 可以取消队列的所有操作。
- (BOOL)isSuspended; 判断队列是否处于暂停状态。 YES 为暂停状态，NO 为恢复状态。
- (void)setSuspended:(BOOL)b; 可设置操作的暂停和恢复，YES 代表暂停队列，NO 代表恢复队列。
操作同步
- (void)waitUntilAllOperationsAreFinished; 阻塞当前线程，直到队列中的操作全部执行完毕。
添加/获取操作`
- (void)addOperationWithBlock:(void (^)(void))block; 向队列中添加一个 NSBlockOperation 类型操作对象。
- (void)addOperations:(NSArray *)ops waitUntilFinished:(BOOL)wait; 向队列中添加操作数组，wait 标志是否阻塞当前线程直到所有操作结束
- (NSArray *)operations; 当前在队列中的操作数组（某个操作执行结束后会自动从这个数组清除）。
- (NSUInteger)operationCount; 当前队列中的操作数。
获取队列
+ (id)currentQueue; 获取当前队列，如果当前线程不是在 NSOperationQueue 上运行则返回 nil。
+ (id)mainQueue; 获取主队列。
</code></pre>
<p>注意：</p>
<p>这里的暂停和取消（包括操作的取消和队列的取消）并不代表可以将当前的操作立即取消，而是当当前的操作执行完毕之后不再执行新的操作。</p>
<p>暂停和取消的区别就在于：暂停操作之后还可以恢复操作，继续向下执行；而取消操作之后，所有的操作就清空了，无法再接着执行剩下的操作。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[我看GCD]]></title>
        <id>https://fanyuecheng.github.io/post/wo-kan-gcd/</id>
        <link href="https://fanyuecheng.github.io/post/wo-kan-gcd/">
        </link>
        <updated>2021-01-05T08:05:33.000Z</updated>
        <content type="html"><![CDATA[<h2 id="gcd-简介">GCD 简介</h2>
<p>什么是 『GCD』 ？</p>
<p>引百度百科<br>
Grand Central Dispatch（GCD） 是 Apple 开发的一个多核编程的较新的解决方法。它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。它是一个在线程池模式的基础上执行的并发任务。在 Mac OS X 10.6 雪豹中首次推出，也可在 iOS 4 及以上版本使用。</p>
<p>GCD的优点：<br>
GCD 可用于多核的并行运算；<br>
GCD 会自动利用更多的 CPU 内核（比如双核、四核）；<br>
GCD 会自动管理线程的生命周期（创建线程、调度任务、销毁线程）；<br>
程序员只需要告诉 GCD 想要执行什么任务，不需要编写任何线程管理代码。</p>
<h2 id="gcd-任务和队列">GCD 任务和队列</h2>
<p>学习 GCD 之前，先来了解 GCD 中两个核心概念：『任务』 和 『队列』。</p>
<p>任务：就是执行操作的意思，换句话说就是你在线程中执行的那段代码。在 GCD 中是放在 block 中的。<br>
执行任务有两种方式：『同步执行』 和 『异步执行』。<br>
两者的主要区别是：是否等待队列的任务执行结束，以及是否具备开启新线程的能力。</p>
<p>同步执行（sync） ：<br>
同步添加任务到指定的队列中，在添加的任务执行结束之前，会一直等待，直到队列里面的任务完成之后再继续执行。<br>
只能在当前线程中执行任务，不具备开启新线程的能力。</p>
<p>异步执行（async） ：<br>
异步添加任务到指定的队列中，它不会做任何等待，可以继续执行任务。<br>
可以在新的线程中执行任务，具备开启新线程的能力。</p>
<p>举个简单例子：你要打电话给小明和小白。</p>
<p>『同步执行』 就是：你打电话给小明的时候，不能同时打给小白。只有等到给小明打完了，才能打给小白（等待任务执行结束）。而且只能用当前的电话（不具备开启新线程的能力）。<br>
『异步执行』 就是：你打电话给小明的时候，不用等着和小明通话结束（不用等待任务执行结束），还能同时给小白打电话。而且除了当前电话，你还可以使用其他一个或多个电话（具备开启新线程的能力）。</p>
<p>注意：异步执行（async）虽然具有开启新线程的能力，但是并不一定开启新线程。这跟任务所指定的队列类型有关（下面会讲）。</p>
<p>队列（Dispatch Queue）：这里的队列指执行任务的等待队列，即用来存放任务的队列。队列是一种特殊的线性表，采用 FIFO（先进先出）的原则，即新任务总是被插入到队列的末尾，而读取任务的时候总是从队列的头部开始读取。每读取一个任务，则从队列中释放一个任务。队列的结构可参考下图：</p>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2019/12/03/GPa2S8E5uvpF4mX.png" alt="队列的结构" loading="lazy"></figure>
<p>在 GCD 中有两种队列：『串行队列』 和 『并发队列』。<br>
两者都符合 FIFO（先进先出）的原则。<br>
两者的主要区别是：执行顺序不同，以及开启线程数不同。</p>
<p>串行队列（Serial Dispatch Queue）：<br>
每次只有一个任务被执行。让任务一个接着一个地执行。（只开启一个线程，一个任务执行完毕后，再执行下一个任务）<br>
并发队列（Concurrent Dispatch Queue）：<br>
可以让多个任务并发（同时）执行。（可以开启多个线程，并且同时执行任务）<br>
注意：并发队列 的并发功能只有在异步（dispatch_async）方法下才有效。</p>
<p>两者具体区别如下两图所示：</p>
<p><img src="https://i.loli.net/2019/12/03/XLQdvoMu2DyV1z8.png" alt="1" loading="lazy"><br>
<img src="https://i.loli.net/2019/12/03/4mWcbJ78CSo1ulO.png" alt="2" loading="lazy"></p>
<h2 id="gcd-的使用步骤">GCD 的使用步骤</h2>
<p>GCD 的使用步骤其实很简单，只有两步：</p>
<p>创建一个队列（串行队列或并发队列）；<br>
将任务追加到任务的等待队列中，然后系统就会根据任务类型执行任务（同步执行或异步执行）。</p>
<p>队列的创建方法 / 获取方法</p>
<p>可以使用 dispatch_queue_create 方法来创建队列。该方法需要传入两个参数：<br>
第一个参数表示队列的唯一标识符，用于 DEBUG，可为空。队列的名称推荐使用应用程序 ID 这种逆序全程域名。<br>
第二个参数用来识别是串行队列还是并发队列。DISPATCH_QUEUE_SERIAL 表示串行队列，DISPATCH_QUEUE_CONCURRENT 表示并发队列。</p>
<pre><code>// 串行队列的创建方法
dispatch_queue_t queue = dispatch_queue_create(&quot;testQueue&quot;, DISPATCH_QUEUE_SERIAL);
// 并发队列的创建方法
dispatch_queue_t queue = dispatch_queue_create(&quot;testQueue&quot;, DISPATCH_QUEUE_CONCURRENT);
</code></pre>
<p>对于串行队列，GCD 默认提供了：『主队列（Main Dispatch Queue）』。<br>
所有放在主队列中的任务，都会放到主线程中执行。</p>
<p>可使用 dispatch_get_main_queue() 方法获得主队列。<br>
注意：主队列其实并不特殊。<br>
主队列的实质上就是一个普通的串行队列，只是因为默认情况下，当前代码是放在主队列中的，然后主队列中的代码，有都会放到主线程中去执行，所以才造成了主队列特殊的现象。</p>
<p>// 主队列的获取方法<br>
<code>dispatch_queue_t queue = dispatch_get_main_queue();</code><br>
对于并发队列，GCD 默认提供了 『全局并发队列（Global Dispatch Queue）』。<br>
可以使用 dispatch_get_global_queue 方法来获取全局并发队列。需要传入两个参数。<br>
第一个参数表示队列优先级，一般用 DISPATCH_QUEUE_PRIORITY_DEFAULT。<br>
第二个参数暂时没用，用 0 即可。</p>
<p>// 全局并发队列的获取方法<br>
<code>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</code><br>
任务的创建方法</p>
<p>GCD 提供了同步执行任务的创建方法 dispatch_sync 和异步执行任务创建方法 dispatch_async。</p>
<p>// 同步执行任务创建方法</p>
<pre><code>dispatch_sync(queue, ^{
    // 这里放同步执行任务代码
});
</code></pre>
<p>// 异步执行任务创建方法</p>
<pre><code>dispatch_async(queue, ^{
    // 这里放异步执行任务代码
});
</code></pre>
<p>虽然使用 GCD 只需两步，但是既然我们有两种队列（串行队列 / 并发队列），两种任务执行方式（同步执行 / 异步执行），那么我们就有了四种不同的组合方式。</p>
<p>这四种不同的组合方式是：</p>
<p>同步执行 + 并发队列<br>
异步执行 + 并发队列<br>
同步执行 + 串行队列<br>
异步执行 + 串行队列</p>
<p>实际上，刚才还说了两种默认队列：全局并发队列、主队列。全局并发队列可以作为普通并发队列来使用。但是当前代码默认放在主队列中，所以主队列很有必要专门来研究一下，所以我们就又多了两种组合方式。这样就有六种不同的组合方式了。</p>
<p>同步执行 + 主队列<br>
异步执行 + 主队列</p>
<p>任务和队列不同组合方式的区别</p>
<p>我们先来考虑最基本的使用，也就是当前线程为 『主线程』 的环境下，『不同队列』+『不同任务』 简单组合使用的不同区别。暂时不考虑 『队列中嵌套队列』 的这种复杂情况。</p>
<p>『主线程』中，『不同队列』+『不同任务』简单组合的区别：</p>
<p>区别	并发队列	串行队列	主队列<br>
同步（sync）	没有开启新线程，串行执行任务	没有开启新线程，串行执行任务	死锁卡住不执行<br>
异步（async）	有开启新线程，并发执行任务	有开启新线程（1条），串行执行任务	没有开启新线程，串行执行任务<br>
注意：从上边可看出： 『主线程』 中调用 『主队列』+『同步执行』 会导致死锁问题。<br>
这是因为 主队列中追加的同步任务 和 主线程本身的任务 两者之间相互等待，阻塞了 『主队列』，最终造成了主队列所在的线程（主线程）死锁问题。</p>
<p>而如果我们在 『其他线程』 调用 『主队列』+『同步执行』，则不会阻塞 『主队列』，自然也不会造成死锁问题。最终的结果是：不会开启新线程，串行执行任务。</p>
<p>队列嵌套情况下，不同组合方式区别</p>
<p>除了上边提到的『主线程』中调用『主队列』+『同步执行』会导致死锁问题。实际在使用『串行队列』的时候，也可能出现阻塞『串行队列』所在线程的情况发生，从而造成死锁问题。这种情况多见于同一个串行队列的嵌套使用。</p>
<p>比如下面代码这样：在『异步执行』+『串行队列』的任务中，又嵌套了『当前的串行队列』，然后进行『同步执行』。</p>
<pre><code>dispatch_queue_t queue = dispatch_queue_create(&quot;test.queue&quot;, DISPATCH_QUEUE_SERIAL);
dispatch_async(queue, ^{    // 异步执行 + 串行队列
    dispatch_sync(queue, ^{  // 同步执行 + 当前串行队列
        // 追加任务 1
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);      // 打印当前线程
    });
});
</code></pre>
<p>执行上面的代码会导致 串行队列中追加的任务 和 串行队列中原有的任务 两者之间相互等待，阻塞了『串行队列』，最终造成了串行队列所在的线程（子线程）死锁问题。</p>
<p>主队列造成死锁也是基于这个原因，所以，这也进一步说明了主队列其实并不特殊。</p>
<p>关于 『队列中嵌套队列』这种复杂情况，这里也简单做一个总结。不过这里只考虑同一个队列的嵌套情况，关于多个队列的相互嵌套情况还请自行研究，或者等我最新的文章发布。</p>
<p>『不同队列』+『不同任务』 组合，以及 『队列中嵌套队列』 使用的区别：</p>
<p>区别	异步执行+并发队列』嵌套『同一个并发队列』	『同步执行+并发队列』嵌套『同一个并发队列』	『异步执行+串行队列』嵌套『同一个串行队列』	『同步执行+串行队列』嵌套『同一个串行队列』<br>
同步（sync）	没有开启新的线程，串行执行任务	没有开启新线程，串行执行任务	死锁卡住不执行	死锁卡住不执行	<br>
异步（async）	有开启新线程，并发执行任务	有开启新线程，并发执行任务	有开启新线程（1 条），串行执行任务	有开启新线程（1 条），串行执行任务	<br>
好了，关于『不同队列』+『不同任务』 组合不同区别总结就到这里。</p>
<p>关于不同队列和不同任务的形象理解</p>
<p>因为前一段时间看到了有朋友留言说对 异步执行 和 并发队列 中创建线程能力有所不理解，我觉得这个问题的确很容易造成困惑，所以很值得拿来专门分析一下。</p>
<p>异步 + 并发 中的解释： 、<br>
（异步执行具备开启新线程的能力。且并发队列可开启多个线程，同时执行多个任务）</p>
<p>同步 + 并发 中的解释：<br>
（虽然并发队列可以开启多个线程，并且同时执行多个任务。但是因为本身不能创建新线程，只有当前线程这一个线程（同步任务不具备开启新线程的能力）</p>
<p>这个地方看起来有点疑惑，你两个地方分别提到：异步执行开启新线程，并发队列也可以开启新线程，想请教下，你的意思是只有任务才拥有创建新线程的能力，而队列只有开启线程的能力，并不能创建线程 ？这二者是这样的关联吗？</p>
<p>关于这个问题，我想做一个很形象的类比，来帮助大家对 队列、任务 以及 线程 之间关系的理解。</p>
<p>假设现在有 5 个人要穿过一道门禁，这道门禁总共有 10 个入口，管理员可以决定同一时间打开几个入口，可以决定同一时间让一个人单独通过还是多个人一起通过。不过默认情况下，管理员只开启一个入口，且一个通道一次只能通过一个人。</p>
<p>这个故事里，人好比是 任务，管理员好比是 系统，入口则代表 线程。</p>
<p>5 个人表示有 5 个任务，10 个入口代表 10 条线程<br>
串行队列 好比是 5 个人排成一支长队<br>
并发队列 好比是 5 个人排成多支队伍，比如 2 队，或者 3 队<br>
同步任务 好比是管理员只开启了一个入口（当前线程）<br>
异步任务 好比是管理员同时开启了多个入口（当前线程 + 新开的线程）</p>
<p>『异步执行 + 并发队列』 可以理解为：现在管理员开启了多个入口（比如 3 个入口），5 个人排成了多支队伍（比如 3 支队伍），这样这 5 个人就可以 3 个人同时一起穿过门禁了。</p>
<p>『同步执行 + 并发队列』 可以理解为：现在管理员只开启了 1 个入口，5 个人排成了多支队伍。虽然这 5 个人排成了多支队伍，但是只开了 1 个入口啊，这 5 个人虽然都想快点过去，但是 1 个入口一次只能过 1 个人，所以大家就只好一个接一个走过去了，表现的结果就是：顺次通过入口。</p>
<p>换成 GCD 里的语言就是说：</p>
<p>『异步执行 + 并发队列』就是：系统开启了多个线程（主线程+其他子线程），任务可以多个同时运行。</p>
<p>『同步执行 + 并发队列』就是：系统只默认开启了一个主线程，没有开启子线程，虽然任务处于并发队列中，但也只能一个接一个执行了。</p>
<h2 id="gcd-的基本使用">GCD 的基本使用</h2>
<p>先来讲讲并发队列的两种执行方式。</p>
<p>同步执行 + 并发队列</p>
<p>在当前线程中执行任务，不会开启新线程，执行完一个任务，再执行下一个任务。</p>
<pre><code>/**
 * 同步执行 + 并发队列
 * 特点：在当前线程中执行任务，不会开启新线程，执行完一个任务，再执行下一个任务。
 */
- (void)syncConcurrent {
    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程
    NSLog(@&quot;syncConcurrent---begin&quot;);

    dispatch_queue_t queue = dispatch_queue_create(&quot;net.bujige.testQueue&quot;, DISPATCH_QUEUE_CONCURRENT);

    dispatch_sync(queue, ^{
        // 追加任务 1
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);      // 打印当前线程
    });

    dispatch_sync(queue, ^{
        // 追加任务 2
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);      // 打印当前线程
    });

    dispatch_sync(queue, ^{
        // 追加任务 3
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;3---%@&quot;,[NSThread currentThread]);      // 打印当前线程
    });

    NSLog(@&quot;syncConcurrent---end&quot;);
}
</code></pre>
<p>输出结果：</p>
<pre><code>2019-08-08 14:32:53.542816+0800 YC-GCD-demo[16332:4171500] currentThread---&lt;NSThread: 0x600002326940&gt;{number = 1, name = main}
2019-08-08 14:32:53.542964+0800 YC-GCD-demo[16332:4171500] syncConcurrent---begin
2019-08-08 14:32:55.544329+0800 YC-GCD-demo[16332:4171500] 1---&lt;NSThread: 0x600002326940&gt;{number = 1, name = main}
2019-08-08 14:32:57.545779+0800 YC-GCD-demo[16332:4171500] 2---&lt;NSThread: 0x600002326940&gt;{number = 1, name = main}
2019-08-08 14:32:59.547154+0800 YC-GCD-demo[16332:4171500] 3---&lt;NSThread: 0x600002326940&gt;{number = 1, name = main}
2019-08-08 14:32:59.547365+0800 YC-GCD-demo[16332:4171500] syncConcurrent---end
</code></pre>
<p>从 同步执行 + 并发队列 中可看到：</p>
<p>所有任务都是在当前线程（主线程）中执行的，没有开启新的线程（同步执行不具备开启新线程的能力）<br>
所有任务都在打印的 syncConcurrent—begin 和 syncConcurrent—end 之间执行的（同步任务 需要等待队列的任务执行结束）<br>
任务按顺序执行的。按顺序执行的原因：虽然 并发队列 可以开启多个线程，并且同时执行多个任务。但是因为本身不能创建新线程，只有当前线程这一个线程（同步任务 不具备开启新线程的能力），所以也就不存在并发。而且当前线程只有等待当前队列中正在执行的任务执行完毕之后，才能继续接着执行下面的操作（同步任务 需要等待队列的任务执行结束）。所以任务只能一个接一个按顺序执行，不能同时被执行。</p>
<p>异步执行 + 并发队列</p>
<p>可以开启多个线程，任务交替（同时）执行。</p>
<pre><code>/**
 * 异步执行 + 并发队列
 * 特点：可以开启多个线程，任务交替（同时）执行。
 */
- (void)asyncConcurrent {
    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程
    NSLog(@&quot;asyncConcurrent---begin&quot;);

    dispatch_queue_t queue = dispatch_queue_create(&quot;net.bujige.testQueue&quot;, DISPATCH_QUEUE_CONCURRENT);

    dispatch_async(queue, ^{
        // 追加任务 1
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);      // 打印当前线程
    });

    dispatch_async(queue, ^{
        // 追加任务 2
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);      // 打印当前线程
    });

    dispatch_async(queue, ^{
        // 追加任务 3
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;3---%@&quot;,[NSThread currentThread]);      // 打印当前线程
    });

    NSLog(@&quot;asyncConcurrent---end&quot;);
}
</code></pre>
<p>输出结果：</p>
<pre><code>2019-08-08 14:36:37.747966+0800 YC-GCD-demo[17232:4187114] currentThread---&lt;NSThread: 0x60000206d380&gt;{number = 1, name = main}
2019-08-08 14:36:37.748150+0800 YC-GCD-demo[17232:4187114] asyncConcurrent---begin
2019-08-08 14:36:37.748279+0800 YC-GCD-demo[17232:4187114] asyncConcurrent---end
2019-08-08 14:36:39.752523+0800 YC-GCD-demo[17232:4187204] 2---&lt;NSThread: 0x600002010980&gt;{number = 3, name = (null)}
2019-08-08 14:36:39.752527+0800 YC-GCD-demo[17232:4187202] 3---&lt;NSThread: 0x600002018480&gt;{number = 5, name = (null)}
2019-08-08 14:36:39.752527+0800 YC-GCD-demo[17232:4187203] 1---&lt;NSThread: 0x600002023400&gt;{number = 4, name = (null)}
</code></pre>
<p>在 异步执行 + 并发队列 中可以看出：</p>
<p>除了当前线程（主线程），系统又开启了 3 个线程，并且任务是交替/同时执行的。（异步执行 具备开启新线程的能力。且 并发队列 可开启多个线程，同时执行多个任务）。</p>
<p>所有任务是在打印的 syncConcurrent—begin 和 syncConcurrent—end 之后才执行的。说明当前线程没有等待，而是直接开启了新线程，在新线程中执行任务（异步执行 不做等待，可以继续执行任务）。<br>
接下来再来讲讲串行队列的两种执行方式。</p>
<p>同步执行 + 串行队列<br>
不会开启新线程，在当前线程执行任务。任务是串行的，执行完一个任务，再执行下一个任务。</p>
<pre><code>/**
 * 同步执行 + 串行队列
 * 特点：不会开启新线程，在当前线程执行任务。任务是串行的，执行完一个任务，再执行下一个任务。
 */
- (void)syncSerial {
    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程
    NSLog(@&quot;syncSerial---begin&quot;);

    dispatch_queue_t queue = dispatch_queue_create(&quot;net.bujige.testQueue&quot;, DISPATCH_QUEUE_SERIAL);

    dispatch_sync(queue, ^{
        // 追加任务 1
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);      // 打印当前线程
    });
    dispatch_sync(queue, ^{
        // 追加任务 2
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);      // 打印当前线程
    });
    dispatch_sync(queue, ^{
        // 追加任务 3
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;3---%@&quot;,[NSThread currentThread]);      // 打印当前线程
    });

    NSLog(@&quot;syncSerial---end&quot;);
}
</code></pre>
<p>输出结果为：</p>
<pre><code>2019-08-08 14:39:31.366815+0800 YSC-GCD-demo[17285:4197645] currentThread---&lt;NSThread: 0x600001b5e940&gt;{number = 1, name = main}
2019-08-08 14:39:31.366952+0800 YSC-GCD-demo[17285:4197645] syncSerial---begin
2019-08-08 14:39:33.368256+0800 YC-GCD-demo[17285:4197645] 1---&lt;NSThread: 0x600001b5e940&gt;{number = 1, name = main}
2019-08-08 14:39:35.369661+0800 YC-GCD-demo[17285:4197645] 2---&lt;NSThread: 0x600001b5e940&gt;{number = 1, name = main}
2019-08-08 14:39:37.370991+0800 YC-GCD-demo[17285:4197645] 3---&lt;NSThread: 0x600001b5e940&gt;{number = 1, name = main}
2019-08-08 14:39:37.371192+0800 YC-GCD-demo[17285:4197645] syncSerial---end
</code></pre>
<p>在 同步执行 + 串行队列 可以看到：</p>
<p>所有任务都是在当前线程（主线程）中执行的，并没有开启新的线程（同步执行 不具备开启新线程的能力）。</p>
<p>所有任务都在打印的 syncConcurrent—begin 和 syncConcurrent—end 之间执行（同步任务 需要等待队列的任务执行结束）。</p>
<p>任务是按顺序执行的（串行队列 每次只有一个任务被执行，任务一个接一个按顺序执行）。</p>
<p>异步执行 + 串行队列</p>
<p>会开启新线程，但是因为任务是串行的，执行完一个任务，再执行下一个任务</p>
<pre><code>/**
 * 异步执行 + 串行队列
 * 特点：会开启新线程，但是因为任务是串行的，执行完一个任务，再执行下一个任务。
 */
- (void)asyncSerial {
    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程
    NSLog(@&quot;asyncSerial---begin&quot;);

    dispatch_queue_t queue = dispatch_queue_create(&quot;net.bujige.testQueue&quot;, DISPATCH_QUEUE_SERIAL);

    dispatch_async(queue, ^{
        // 追加任务 1
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);      // 打印当前线程
    });
    dispatch_async(queue, ^{
        // 追加任务 2
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);      // 打印当前线程
    });
    dispatch_async(queue, ^{
        // 追加任务 3
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;3---%@&quot;,[NSThread currentThread]);      // 打印当前线程
    });

    NSLog(@&quot;asyncSerial---end&quot;);
}
</code></pre>
<p>输出结果为：</p>
<pre><code>2019-08-08 14:40:53.944502+0800 YSC-GCD-demo[17313:4203018] currentThread---&lt;NSThread: 0x6000015da940&gt;{number = 1, name = main}
2019-08-08 14:40:53.944615+0800 YC-GCD-demo[17313:4203018] asyncSerial---begin
2019-08-08 14:40:53.944710+0800 YC-GCD-demo[17313:4203018] asyncSerial---end
2019-08-08 14:40:55.947709+0800 YC-GCD-demo[17313:4203079] 1---&lt;NSThread: 0x6000015a0840&gt;{number = 3, name = (null)}
2019-08-08 14:40:57.952453+0800 YC-GCD-demo[17313:4203079] 2---&lt;NSThread: 0x6000015a0840&gt;{number = 3, name = (null)}
2019-08-08 14:40:59.952943+0800 YC-GCD-demo[17313:4203079] 3---&lt;NSThread: 0x6000015a0840&gt;{number = 3, name = (null)}
</code></pre>
<p>在 异步执行 + 串行队列 可以看到：</p>
<p>开启了一条新线程（异步执行 具备开启新线程的能力，串行队列 只开启一个线程）。<br>
所有任务是在打印的 syncConcurrent—begin 和 syncConcurrent—end 之后才开始执行的（异步执行 不会做任何等待，可以继续执行任务）。<br>
任务是按顺序执行的（串行队列 每次只有一个任务被执行，任务一个接一个按顺序执行）。</p>
<p>下边讲讲刚才我们提到过的：主队列。</p>
<p>主队列：GCD 默认提供的 串行队列。</p>
<p>默认情况下，平常所写代码是直接放在主队列中的。<br>
所有放在主队列中的任务，都会放到主线程中执行。</p>
<p>可使用 dispatch_get_main_queue() 获得主队列。<br>
我们再来看看主队列的两种组合方式。</p>
<p>同步执行 + 主队列</p>
<p>同步执行 + 主队列 在不同线程中调用结果也是不一样，在主线程中调用会发生死锁问题，而在其他线程中调用则不会。</p>
<p>在主线程中调用 『同步执行 + 主队列』<br>
互相等待卡住不可行</p>
<pre><code>/**
 * 同步执行 + 主队列
 * 特点(主线程调用)：互等卡主不执行。
 * 特点(其他线程调用)：不会开启新线程，执行完一个任务，再执行下一个任务。
 */
- (void)syncMain {

    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程
    NSLog(@&quot;syncMain---begin&quot;);

    dispatch_queue_t queue = dispatch_get_main_queue();

    dispatch_sync(queue, ^{
        // 追加任务 1
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);      // 打印当前线程
    });

    dispatch_sync(queue, ^{
        // 追加任务 2
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);      // 打印当前线程
    });

    dispatch_sync(queue, ^{
        // 追加任务 3
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;3---%@&quot;,[NSThread currentThread]);      // 打印当前线程
    });

    NSLog(@&quot;syncMain---end&quot;);
}
</code></pre>
<p>输出结果</p>
<pre><code>2019-08-08 14:43:58.062376+0800 YC-GCD-demo[17371:4213562] currentThread---&lt;NSThread: 0x6000026e2940&gt;{number = 1, name = main}
2019-08-08 14:43:58.062518+0800 YC-GCD-demo[17371:4213562] syncMain---begin
(lldb)
</code></pre>
<p>在主线程中使用 同步执行 + 主队列 可以惊奇的发现：</p>
<p>追加到主线程的任务 1、任务 2、任务 3 都不再执行了，而且 syncMain—end 也没有打印，在 XCode 9 及以上版本上还会直接报崩溃。这是为什么呢？</p>
<p>这是因为我们在主线程中执行 syncMain 方法，相当于把 syncMain 任务放到了主线程的队列中。而 同步执行 会等待当前队列中的任务执行完毕，才会接着执行。那么当我们把 任务 1 追加到主队列中，任务 1 就在等待主线程处理完 syncMain 任务。而syncMain 任务需要等待 任务 1 执行完毕，才能接着执行。</p>
<p>那么，现在的情况就是 syncMain 任务和 任务 1 都在等对方执行完毕。这样大家互相等待，所以就卡住了，所以我们的任务执行不了，而且 syncMain—end 也没有打印。</p>
<p>要是如果不在主线程中调用，而在其他线程中调用会如何呢？</p>
<p>在其他线程中调用『同步执行 + 主队列』</p>
<p>不会开启新线程，执行完一个任务，再执行下一个任务</p>
<p>// 使用 NSThread 的 detachNewThreadSelector 方法会创建线程，并自动启动线程执行 selector 任务</p>
<pre><code>[NSThread detachNewThreadSelector:@selector(syncMain) toTarget:self withObject:nil];
</code></pre>
<p>输出结果：</p>
<pre><code>2019-08-08 14:51:38.137978+0800 YC-GCD-demo[17482:4237818] currentThread---&lt;NSThread: 0x600001dd6c00&gt;{number = 3, name = (null)}
2019-08-08 14:51:38.138159+0800 YC-GCD-demo[17482:4237818] syncMain---begin
2019-08-08 14:51:40.149065+0800 YC-GCD-demo[17482:4237594] 1---&lt;NSThread: 0x600001d8d380&gt;{number = 1, name = main}
2019-08-08 14:51:42.151104+0800 YC-GCD-demo[17482:4237594] 2---&lt;NSThread: 0x600001d8d380&gt;{number = 1, name = main}
2019-08-08 14:51:44.152583+0800 YC-GCD-demo[17482:4237594] 3---&lt;NSThread: 0x600001d8d380&gt;{number = 1, name = main}
2019-08-08 14:51:44.152767+0800 YC-GCD-demo[17482:4237818] syncMain---end
</code></pre>
<p>在其他线程中使用 同步执行 + 主队列 可看到：</p>
<p>所有任务都是在主线程（非当前线程）中执行的，没有开启新的线程（所有放在主队列中的任务，都会放到主线程中执行）。<br>
所有任务都在打印的 syncConcurrent—begin 和 syncConcurrent—end 之间执行（同步任务 需要等待队列的任务执行结束）。<br>
任务是按顺序执行的（主队列是 串行队列，每次只有一个任务被执行，任务一个接一个按顺序执行）。</p>
<p>为什么现在就不会卡住了呢？</p>
<p>因为syncMain 任务 放到了其他线程里，而 任务 1、任务 2、任务3 都在追加到主队列中，这三个任务都会在主线程中执行。syncMain 任务 在其他线程中执行到追加 任务 1 到主队列中，因为主队列现在没有正在执行的任务，所以，会直接执行主队列的 任务1，等 任务1 执行完毕，再接着执行 任务 2、任务 3。所以这里不会卡住线程，也就不会造成死锁问题。</p>
<p>异步执行 + 主队列<br>
只在主线程中执行任务，执行完一个任务，再执行下一个任务。</p>
<pre><code>/**
 * 异步执行 + 主队列
 * 特点：只在主线程中执行任务，执行完一个任务，再执行下一个任务
 */
- (void)asyncMain {
    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程
    NSLog(@&quot;asyncMain---begin&quot;);

    dispatch_queue_t queue = dispatch_get_main_queue();

    dispatch_async(queue, ^{
        // 追加任务 1
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);      // 打印当前线程
    });

    dispatch_async(queue, ^{
        // 追加任务 2
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);      // 打印当前线程
    });

    dispatch_async(queue, ^{
        // 追加任务 3
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;3---%@&quot;,[NSThread currentThread]);      // 打印当前线程
    });

    NSLog(@&quot;asyncMain---end&quot;);
}
</code></pre>
<p>输出结果：</p>
<pre><code>2019-08-08 14:53:27.023091+0800 YC-GCD-demo[17521:4243690] currentThread---&lt;NSThread: 0x6000022a1380&gt;{number = 1, name = main}
2019-08-08 14:53:27.023247+0800 YC-GCD-demo[17521:4243690] asyncMain---begin
2019-08-08 14:53:27.023399+0800 YC-GCD-demo[17521:4243690] asyncMain---end
2019-08-08 14:53:29.035565+0800 YC-GCD-demo[17521:4243690] 1---&lt;NSThread: 0x6000022a1380&gt;{number = 1, name = main}
2019-08-08 14:53:31.036565+0800 YC-GCD-demo[17521:4243690] 2---&lt;NSThread: 0x6000022a1380&gt;{number = 1, name = main}
2019-08-08 14:53:33.037092+0800 YC-GCD-demo[17521:4243690] 3---&lt;NSThread: 0x6000022a1380&gt;{number = 1, name = main}
</code></pre>
<p>在 异步执行 + 主队列 可以看到：</p>
<p>所有任务都是在当前线程（主线程）中执行的，并没有开启新的线程（虽然 异步执行 具备开启线程的能力，但因为是主队列，所以所有任务都在主线程中）。<br>
所有任务是在打印的 syncConcurrent—begin 和 syncConcurrent—end 之后才开始执行的（异步执行不会做任何等待，可以继续执行任务）。<br>
任务是按顺序执行的（因为主队列是 串行队列，每次只有一个任务被执行，任务一个接一个按顺序执行）。</p>
<h2 id="gcd-线程间的通信">GCD 线程间的通信</h2>
<p>在 iOS 开发过程中，我们一般在主线程里边进行 UI 刷新，例如：点击、滚动、拖拽等事件。我们通常把一些耗时的操作放在其他线程，比如说图片下载、文件上传等耗时操作。而当我们有时候在其他线程完成了耗时操作时，需要回到主线程，那么就用到了线程之间的通讯。</p>
<pre><code>/**
 * 线程间通信
 */
- (void)communication {
    // 获取全局并发队列
    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    // 获取主队列
    dispatch_queue_t mainQueue = dispatch_get_main_queue();

    dispatch_async(queue, ^{
        // 异步追加任务 1
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);      // 打印当前线程

        // 回到主线程
        dispatch_async(mainQueue, ^{
            // 追加在主线程中执行的任务
            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
            NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);      // 打印当前线程
        });
    });
}
</code></pre>
<p>输出结果：</p>
<pre><code>2019-08-08 14:56:22.973318+0800 YC-GCD-demo[17573:4253201] 1---&lt;NSThread: 0x600001846080&gt;{number = 3, name = (null)}
2019-08-08 14:56:24.973902+0800 YC-GCD-demo[17573:4253108] 2---&lt;NSThread: 0x60000181e940&gt;{number = 1, name = main}
</code></pre>
<p>可以看到在其他线程中先执行任务，执行完了之后回到主线程执行主线程的相应操作。</p>
<h2 id="gcd-的其他方法">GCD 的其他方法</h2>
<p>GCD 栅栏方法：dispatch_barrier_async</p>
<p>我们有时需要异步执行两组操作，而且第一组操作执行完之后，才能开始执行第二组操作。这样我们就需要一个相当于 栅栏 一样的一个方法将两组异步执行的操作组给分割起来，当然这里的操作组里可以包含一个或多个任务。这就需要用到dispatch_barrier_async 方法在两个操作组间形成栅栏。</p>
<p>dispatch_barrier_async 方法会等待前边追加到并发队列中的任务全部执行完毕之后，再将指定的任务追加到该异步队列中。然后在 dispatch_barrier_async 方法追加的任务执行完毕之后，异步队列才恢复为一般动作，接着追加任务到该异步队列并开始执行。<br>
<img src="https://i.loli.net/2019/12/03/w35nuPNLkGsd2Bp.png" alt="dispatch_barrier_async" loading="lazy"></p>
<pre><code>/**
 * 栅栏方法 dispatch_barrier_async
 */
- (void)barrier {
    dispatch_queue_t queue = dispatch_queue_create(&quot;net.bujige.testQueue&quot;, DISPATCH_QUEUE_CONCURRENT);

    dispatch_async(queue, ^{
        // 追加任务 1
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);      // 打印当前线程
    });
    dispatch_async(queue, ^{
        // 追加任务 2
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);      // 打印当前线程
    });

    dispatch_barrier_async(queue, ^{
        // 追加任务 barrier
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;barrier---%@&quot;,[NSThread currentThread]);// 打印当前线程
    });

    dispatch_async(queue, ^{
        // 追加任务 3
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;3---%@&quot;,[NSThread currentThread]);      // 打印当前线程
    });
    dispatch_async(queue, ^{
        // 追加任务 4
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;4---%@&quot;,[NSThread currentThread]);      // 打印当前线程
    });
}
</code></pre>
<p>输出结果：</p>
<pre><code>2019-08-08 14:59:02.540868+0800 YC-GCD-demo[17648:4262933] 1---&lt;NSThread: 0x600001ca4c40&gt;{number = 3, name = (null)}
2019-08-08 14:59:02.540868+0800 YC-GCD-demo[17648:4262932] 2---&lt;NSThread: 0x600001c84a00&gt;{number = 4, name = (null)}
2019-08-08 14:59:04.542346+0800 YC-GCD-demo[17648:4262933] barrier---&lt;NSThread: 0x600001ca4c40&gt;{number = 3, name = (null)}
2019-08-08 14:59:06.542772+0800 YC-GCD-demo[17648:4262932] 4---&lt;NSThread: 0x600001c84a00&gt;{number = 4, name = (null)}
2019-08-08 14:59:06.542773+0800 YC-GCD-demo[17648:4262933] 3---&lt;NSThread: 0x600001ca4c40&gt;{number = 3, name = (null)}
</code></pre>
<p>在 dispatch_barrier_async 执行结果中可以看出：</p>
<p>在执行完栅栏前面的操作之后，才执行栅栏操作，最后再执行栅栏后边的操作。</p>
<p>GCD 延时执行方法：dispatch_after</p>
<p>我们经常会遇到这样的需求：在指定时间（例如 3 秒）之后执行某个任务。可以用 GCD 的dispatch_after 方法来实现。</p>
<p>需要注意的是：dispatch_after 方法并不是在指定时间之后才开始执行处理，而是在指定时间之后将任务追加到主队列中。严格来说，这个时间并不是绝对准确的，但想要大致延迟执行任务，dispatch_after 方法是很有效的。</p>
<pre><code>/**
 * 延时执行方法 dispatch_after
 */
- (void)after {
    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程
    NSLog(@&quot;asyncMain---begin&quot;);

    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
        // 2.0 秒后异步追加任务代码到主队列，并开始执行
        NSLog(@&quot;after---%@&quot;,[NSThread currentThread]);  // 打印当前线程
    });
}
</code></pre>
<p>输出结果：</p>
<pre><code>2019-08-08 15:01:33.569710+0800 YC-GCD-demo[17702:4272430] currentThread---&lt;NSThread: 0x600001ead340&gt;{number = 1, name = main}
2019-08-08 15:01:33.569838+0800 YC-GCD-demo[17702:4272430] asyncMain---begin
2019-08-08 15:01:35.570146+0800 YC-GCD-demo[17702:4272430] after---&lt;NSThread: 0x600001ead340&gt;{number = 1, name = main}
</code></pre>
<p>可以看出：在打印 asyncMain—begin 之后大约 2.0 秒的时间，打印了 after—{number = 1, name = main}</p>
<p>GCD 一次性代码（只执行一次）：dispatch_once</p>
<p>我们在创建单例、或者有整个程序运行过程中只执行一次的代码时，我们就用到了 GCD 的 dispatch_once 方法。使用 dispatch_once 方法能保证某段代码在程序运行过程中只被执行 1 次，并且即使在多线程的环境下，dispatch_once 也可以保证线程安全。</p>
<pre><code>/**
 * 一次性代码（只执行一次）dispatch_once
 */
- (void)once {
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        // 只执行 1 次的代码（这里面默认是线程安全的）
    });
}
</code></pre>
<p>GCD 快速迭代方法：dispatch_apply</p>
<p>通常我们会用 for 循环遍历，但是 GCD 给我们提供了快速迭代的方法 dispatch_apply。dispatch_apply 按照指定的次数将指定的任务追加到指定的队列中，并等待全部队列执行结束。<br>
如果是在串行队列中使用 dispatch_apply，那么就和 for 循环一样，按顺序同步执行。但是这样就体现不出快速迭代的意义了。</p>
<p>我们可以利用并发队列进行异步执行。比如说遍历 0~5 这 6 个数字，for 循环的做法是每次取出一个元素，逐个遍历。dispatch_apply 可以 在多个线程中同时（异步）遍历多个数字。</p>
<p>还有一点，无论是在串行队列，还是并发队列中，dispatch_apply 都会等待全部任务执行完毕，这点就像是同步操作，也像是队列组中的 dispatch_group_wait方法。</p>
<pre><code>/**
 * 快速迭代方法 dispatch_apply
 */
- (void)apply {
    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);

    NSLog(@&quot;apply---begin&quot;);
    dispatch_apply(6, queue, ^(size_t index) {
        NSLog(@&quot;%zd---%@&quot;,index, [NSThread currentThread]);
    });
    NSLog(@&quot;apply---end&quot;);
}
</code></pre>
<p>输出结果：</p>
<pre><code>2019-08-08 15:05:04.715266+0800 YC-GCD-demo[17771:4285619] apply---begin
2019-08-08 15:05:04.715492+0800 YC-GCD-demo[17771:4285619] 0---&lt;NSThread: 0x600003bd1380&gt;{number = 1, name = main}
2019-08-08 15:05:04.715516+0800 YC-GCD-demo[17771:4285722] 1---&lt;NSThread: 0x600003b82340&gt;{number = 3, name = (null)}
2019-08-08 15:05:04.715526+0800 YC-GCD-demo[17771:4285720] 3---&lt;NSThread: 0x600003ba4cc0&gt;{number = 5, name = (null)}
2019-08-08 15:05:04.715564+0800 YC-GCD-demo[17771:4285721] 2---&lt;NSThread: 0x600003bb9a80&gt;{number = 7, name = (null)}
2019-08-08 15:05:04.715555+0800 YC-GCD-demo[17771:4285719] 4---&lt;NSThread: 0x600003b98100&gt;{number = 6, name = (null)}
2019-08-08 15:05:04.715578+0800 YC-GCD-demo[17771:4285728] 5---&lt;NSThread: 0x600003beb400&gt;{number = 4, name = (null)}
2019-08-08 15:05:04.715677+0800 YC-GCD-demo[17771:4285619] apply---end
</code></pre>
<p>因为是在并发队列中异步执行任务，所以各个任务的执行时间长短不定，最后结束顺序也不定。但是 apply—end 一定在最后执行。这是因为 dispatch_apply 方法会等待全部任务执行完毕。</p>
<p>GCD 队列组：dispatch_group</p>
<p>有时候我们会有这样的需求：分别异步执行2个耗时任务，然后当2个耗时任务都执行完毕后再回到主线程执行任务。这时候我们可以用到 GCD 的队列组。</p>
<p>调用队列组的 dispatch_group_async 先把任务放到队列中，然后将队列放入队列组中。或者使用队列组的 dispatch_group_enter、dispatch_group_leave 组合来实现 dispatch_group_async。</p>
<p>调用队列组的 dispatch_group_notify 回到指定线程执行任务。或者使用 dispatch_group_wait 回到当前线程继续向下执行（会阻塞当前线程）</p>
<p>dispatch_group_notify</p>
<p>监听 group 中任务的完成状态，当所有的任务都执行完成后，追加任务到 group 中，并执行任务。</p>
<pre><code>/**
 * 队列组 dispatch_group_notify
 */
- (void)groupNotify {
    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程
    NSLog(@&quot;group---begin&quot;);

    dispatch_group_t group =  dispatch_group_create();

    dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        // 追加任务 1
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);      // 打印当前线程
    });

    dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        // 追加任务 2
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);      // 打印当前线程
    });

    dispatch_group_notify(group, dispatch_get_main_queue(), ^{
        // 等前面的异步任务 1、任务 2 都执行完毕后，回到主线程执行下边任务
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;3---%@&quot;,[NSThread currentThread]);      // 打印当前线程

        NSLog(@&quot;group---end&quot;);
    });
}
</code></pre>
<p>输出结果：</p>
<pre><code>2019-08-08 15:07:21.601734+0800 YC-GCD-demo[17813:4293874] currentThread---&lt;NSThread: 0x600003aad380&gt;{number = 1, name = main}
2019-08-08 15:07:21.601871+0800 YC-GCD-demo[17813:4293874] group---begin
2019-08-08 15:07:23.604854+0800 YC-GCD-demo[17813:4294048] 2---&lt;NSThread: 0x600003add100&gt;{number = 4, name = (null)}
2019-08-08 15:07:23.604852+0800 YC-GCD-demo[17813:4294053] 1---&lt;NSThread: 0x600003ace4c0&gt;{number = 3, name = (null)}
2019-08-08 15:07:25.606067+0800 YC-GCD-demo[17813:4293874] 3---&lt;NSThread: 0x600003aad380&gt;{number = 1, name = main}
2019-08-08 15:07:25.606255+0800 YC-GCD-demo[17813:4293874] group---end
从 dispatch_group_notify 相关代码运行输出结果可以看出：
</code></pre>
<p>当所有任务都执行完成之后，才执行 dispatch_group_notify 相关 block 中的任务。</p>
<p>dispatch_group_wait</p>
<p>暂停当前线程（阻塞当前线程），等待指定的 group 中的任务执行完成后，才会往下继续执行。</p>
<pre><code>/**
 * 队列组 dispatch_group_wait
 */
- (void)groupWait {
    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程
    NSLog(@&quot;group---begin&quot;);

    dispatch_group_t group =  dispatch_group_create();

    dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        // 追加任务 1
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);      // 打印当前线程
    });

    dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        // 追加任务 2
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);      // 打印当前线程
    });

    // 等待上面的任务全部完成后，会往下继续执行（会阻塞当前线程）
    dispatch_group_wait(group, DISPATCH_TIME_FOREVER);

    NSLog(@&quot;group---end&quot;);

}
</code></pre>
<p>输出结果：</p>
<pre><code>2019-08-08 15:09:12.441729+0800 YC-GCD-demo[17844:4299926] currentThread---&lt;NSThread: 0x6000013e2940&gt;{number = 1, name = main}
2019-08-08 15:09:12.441870+0800 YC-GCD-demo[17844:4299926] group---begin
2019-08-08 15:09:14.445790+0800 YC-GCD-demo[17844:4300046] 2---&lt;NSThread: 0x600001389780&gt;{number = 4, name = (null)}
2019-08-08 15:09:14.445760+0800 YC-GCD-demo[17844:4300043] 1---&lt;NSThread: 0x600001381880&gt;{number = 3, name = (null)}
2019-08-08 15:09:14.446039+0800 YC-GCD-demo[17844:4299926] group---end
</code></pre>
<p>从 dispatch_group_wait 相关代码运行输出结果可以看出：</p>
<p>当所有任务执行完成之后，才执行 dispatch_group_wait 之后的操作。但是，使用dispatch_group_wait 会阻塞当前线程。</p>
<p>dispatch_group_enter、dispatch_group_leave</p>
<p>dispatch_group_enter 标志着一个任务追加到 group，执行一次，相当于 group 中未执行完毕任务数 +1</p>
<p>dispatch_group_leave 标志着一个任务离开了 group，执行一次，相当于 group 中未执行完毕任务数 -1。</p>
<p>当 group 中未执行完毕任务数为0的时候，才会使 dispatch_group_wait 解除阻塞，以及执行追加到 dispatch_group_notify 中的任务。</p>
<pre><code>/**
 * 队列组 dispatch_group_enter、dispatch_group_leave
 */
- (void)groupEnterAndLeave {
    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程
    NSLog(@&quot;group---begin&quot;);

    dispatch_group_t group = dispatch_group_create();
    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    dispatch_group_enter(group);
    dispatch_async(queue, ^{
        // 追加任务 1
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);      // 打印当前线程

        dispatch_group_leave(group);
    });

    dispatch_group_enter(group);
    dispatch_async(queue, ^{
        // 追加任务 2
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);      // 打印当前线程

        dispatch_group_leave(group);
    });

    dispatch_group_notify(group, dispatch_get_main_queue(), ^{
        // 等前面的异步操作都执行完毕后，回到主线程.
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;3---%@&quot;,[NSThread currentThread]);      // 打印当前线程

        NSLog(@&quot;group---end&quot;);
    });
}
</code></pre>
<p>输出结果：</p>
<pre><code>2019-08-08 15:13:17.983283+0800 YC-GCD-demo[17924:4314716] currentThread---&lt;NSThread: 0x600001ee5380&gt;{number = 1, name = main}
2019-08-08 15:13:17.983429+0800 YC-GCD-demo[17924:4314716] group---begin
2019-08-08 15:13:19.988898+0800 YC-GCD-demo[17924:4314816] 2---&lt;NSThread: 0x600001e9ca00&gt;{number = 3, name = (null)}
2019-08-08 15:13:19.988888+0800 YC-GCD-demo[17924:4314808] 1---&lt;NSThread: 0x600001e94100&gt;{number = 4, name = (null)}
2019-08-08 15:13:21.990450+0800 YC-GCD-demo[17924:4314716] 3---&lt;NSThread: 0x600001ee5380&gt;{number = 1, name = main}
2019-08-08 15:13:21.990711+0800 YC-GCD-demo[17924:4314716] group---end
</code></pre>
<p>从 dispatch_group_enter、dispatch_group_leave 相关代码运行结果中可以看出：当所有任务执行完成之后，才执行 dispatch_group_notify 中的任务。这里的dispatch_group_enter、dispatch_group_leave 组合，其实等同于dispatch_group_async。</p>
<p>GCD 信号量：dispatch_semaphore</p>
<p>GCD 中的信号量是指 Dispatch Semaphore，是持有计数的信号。类似于过高速路收费站的栏杆。可以通过时，打开栏杆，不可以通过时，关闭栏杆。在 Dispatch</p>
<p>Semaphore 中，使用计数来完成这个功能，计数小于 0 时等待，不可通过。计数为 0 或大于 0 时，计数减 1 且不等待，可通过。</p>
<p>Dispatch Semaphore 提供了三个方法：<br>
dispatch_semaphore_create：创建一个 Semaphore 并初始化信号的总量<br>
dispatch_semaphore_signal：发送一个信号，让信号总量加 1<br>
dispatch_semaphore_wait：可以使总信号量减 1，信号总量小于 0 时就会一直等待（阻塞所在线程），否则就可以正常执行。</p>
<p>注意：信号量的使用前提是：想清楚你需要处理哪个线程等待（阻塞），又要哪个线程继续执行，然后使用信号量。</p>
<p>Dispatch Semaphore 在实际开发中主要用于：<br>
保持线程同步，将异步执行任务转换为同步执行任务<br>
保证线程安全，为线程加锁</p>
<p>Dispatch Semaphore 线程同步</p>
<p>我们在开发中，会遇到这样的需求：异步执行耗时任务，并使用异步执行的结果进行一些额外的操作。换句话说，相当于，将将异步执行任务转换为同步执行任务。比如说：AFNetworking 中 AFURLSessionManager.m 里面的 tasksForKeyPath: 方法。通过引入信号量的方式，等待异步执行任务结果，获取到 tasks，然后再返回该 tasks。</p>
<pre><code>- (NSArray *)tasksForKeyPath:(NSString *)keyPath {
    __block NSArray *tasks = nil;
    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);
    [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) {
        if ([keyPath isEqualToString:NSStringFromSelector(@selector(dataTasks))]) {
            tasks = dataTasks;
        } else if ([keyPath isEqualToString:NSStringFromSelector(@selector(uploadTasks))]) {
            tasks = uploadTasks;
        } else if ([keyPath isEqualToString:NSStringFromSelector(@selector(downloadTasks))]) {
            tasks = downloadTasks;
        } else if ([keyPath isEqualToString:NSStringFromSelector(@selector(tasks))]) {
            tasks = [@[dataTasks, uploadTasks, downloadTasks] valueForKeyPath:@&quot;@unionOfArrays.self&quot;];
        }

        dispatch_semaphore_signal(semaphore);
    }];

    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);

    return tasks;
}
</code></pre>
<p>下面，我们来利用 Dispatch Semaphore 实现线程同步，将异步执行任务转换为同步执行任务。</p>
<pre><code>/**
 * semaphore 线程同步
 */
- (void)semaphoreSync {

    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程
    NSLog(@&quot;semaphore---begin&quot;);

    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);

    __block int number = 0;
    dispatch_async(queue, ^{
        // 追加任务 1
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);      // 打印当前线程

        number = 100;

        dispatch_semaphore_signal(semaphore);
    });

    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
    NSLog(@&quot;semaphore---end,number = %zd&quot;,number);
}
</code></pre>
<p>输出结果：</p>
<pre><code>2019-08-08 15:16:56.781543+0800 YC-GCD-demo[17988:4325744] currentThread---&lt;NSThread: 0x60000298d380&gt;{number = 1, name = main}
2019-08-08 15:16:56.781698+0800 YC-GCD-demo[17988:4325744] semaphore---begin
2019-08-08 15:16:58.785232+0800 YC-GCD-demo[17988:4325867] 1---&lt;NSThread: 0x6000029eba80&gt;{number = 3, name = (null)}
2019-08-08 15:16:58.785432+0800 YC-GCD-demo[17988:4325744] semaphore---end,number = 100
</code></pre>
<p>从 Dispatch Semaphore 实现线程同步的代码可以看到：</p>
<p>semaphore—end 是在执行完 number = 100; 之后才打印的。而且输出结果 number 为 100。这是因为 异步执行 不会做任何等待，可以继续执行任务。</p>
<p>执行顺如下：<br>
semaphore 初始创建时计数为 0。<br>
异步执行 将 任务 1 追加到队列之后，不做等待，接着执行<br>
dispatch_semaphore_wait 方法，semaphore 减 1，此时 semaphore == -1，当前线程进入等待状态。<br>
然后，异步任务 1 开始执行。任务 1 执行到 dispatch_semaphore_signal 之后，总信号量加 1，此时 semaphore == 0，正在被阻塞的线程（主线程）恢复继续执行。<br>
最后打印 semaphore—end,number = 100。<br>
这样就实现了线程同步，将异步执行任务转换为同步执行任务。</p>
<p>Dispatch Semaphore 线程安全和线程同步（为线程加锁）</p>
<p>线程安全：如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。</p>
<p>若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作（更改变量），一般都需要考虑线程同步，否则的话就可能影响线程安全。</p>
<p>线程同步：可理解为线程 A 和 线程 B 一块配合，A 执行到一定程度时要依靠线程 B 的某个结果，于是停下来，示意 B 运行；B 依言执行，再将结果给 A；A 再继续操作。</p>
<p>举个简单例子就是：两个人在一起聊天。两个人不能同时说话，避免听不清(操作冲突)。等一个人说完(一个线程结束操作)，另一个再说(另一个线程再开始操作)。</p>
<p>下面，我们模拟火车票售卖的方式，实现 NSThread 线程安全和解决线程同步问题。<br>
场景：总共有 50 张火车票，有两个售卖火车票的窗口，一个是北京火车票售卖窗口，另一个是上海火车票售卖窗口。两个窗口同时售卖火车票，卖完为止。</p>
<p>非线程安全（不使用 semaphore）<br>
先来看看不考虑线程安全的代码：</p>
<pre><code>/**
 * 非线程安全：不使用 semaphore
 * 初始化火车票数量、卖票窗口（非线程安全）、并开始卖票
 */
- (void)initTicketStatusNotSave {
    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程
    NSLog(@&quot;semaphore---begin&quot;);

    self.ticketSurplusCount = 50;

    // queue1 代表北京火车票售卖窗口
    dispatch_queue_t queue1 = dispatch_queue_create(&quot;net.bujige.testQueue1&quot;, DISPATCH_QUEUE_SERIAL);
    // queue2 代表上海火车票售卖窗口
    dispatch_queue_t queue2 = dispatch_queue_create(&quot;net.bujige.testQueue2&quot;, DISPATCH_QUEUE_SERIAL);

    __weak typeof(self) weakSelf = self;
    dispatch_async(queue1, ^{
        [weakSelf saleTicketNotSafe];
    });

    dispatch_async(queue2, ^{
        [weakSelf saleTicketNotSafe];
    });
}

/**
 * 售卖火车票（非线程安全）
 */
- (void)saleTicketNotSafe {
    while (1) {

        if (self.ticketSurplusCount &gt; 0) {  // 如果还有票，继续售卖
            self.ticketSurplusCount--;
            NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;剩余票数：%d 窗口：%@&quot;, self.ticketSurplusCount, [NSThread currentThread]]);
            [NSThread sleepForTimeInterval:0.2];
        } else { // 如果已卖完，关闭售票窗口
            NSLog(@&quot;所有火车票均已售完&quot;);
            break;
        }

    }
}
</code></pre>
<p>输出结果（部分）：</p>
<pre><code>2019-08-08 15:21:39.772655+0800 YC-GCD-demo[18071:4340555] currentThread---&lt;NSThread: 0x6000015a2f40&gt;{number = 1, name = main}
2019-08-08 15:21:39.772790+0800 YC-GCD-demo[18071:4340555] semaphore---begin
2019-08-08 15:21:39.773101+0800 YC-GCD-demo[18071:4340604] 剩余票数：48 窗口：&lt;NSThread: 0x6000015cc600&gt;{number = 4, name = (null)}
2019-08-08 15:21:39.773115+0800 YC-GCD-demo[18071:4340605] 剩余票数：49 窗口：&lt;NSThread: 0x6000015f8600&gt;{number = 3, name = (null)}
2019-08-08 15:21:39.975041+0800 YC-GCD-demo[18071:4340605] 剩余票数：47 窗口：&lt;NSThread: 0x6000015f8600&gt;{number = 3, name = (null)}
2019-08-08 15:21:39.975037+0800 YC-GCD-demo[18071:4340604] 剩余票数：47 窗口：&lt;NSThread: 0x6000015cc600&gt;{number = 4, name = (null)}
2019-08-08 15:21:40.176567+0800 YC-GCD-demo[18071:4340604] 剩余票数：46 窗口：&lt;NSThread: 0x6000015cc600&gt;{number = 4, name = (null)}
...
</code></pre>
<p>可以看到在不考虑线程安全，不使用 semaphore 的情况下，得到票数是错乱的，这样显然不符合我们的需求，所以我们需要考虑线程安全问题。</p>
<p>线程安全（使用 semaphore 加锁）</p>
<p>考虑线程安全的代码：</p>
<pre><code>/**
 * 线程安全：使用 semaphore 加锁
 * 初始化火车票数量、卖票窗口（线程安全）、并开始卖票
 */
- (void)initTicketStatusSave {
    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程
    NSLog(@&quot;semaphore---begin&quot;);

    semaphoreLock = dispatch_semaphore_create(1);

    self.ticketSurplusCount = 50;

    // queue1 代表北京火车票售卖窗口
    dispatch_queue_t queue1 = dispatch_queue_create(&quot;net.bujige.testQueue1&quot;, DISPATCH_QUEUE_SERIAL);
    // queue2 代表上海火车票售卖窗口
    dispatch_queue_t queue2 = dispatch_queue_create(&quot;net.bujige.testQueue2&quot;, DISPATCH_QUEUE_SERIAL);

    __weak typeof(self) weakSelf = self;
    dispatch_async(queue1, ^{
        [weakSelf saleTicketSafe];
    });

    dispatch_async(queue2, ^{
        [weakSelf saleTicketSafe];
    });
}

/**
 * 售卖火车票（线程安全）
 */
- (void)saleTicketSafe {
    while (1) {
        // 相当于加锁
        dispatch_semaphore_wait(semaphoreLock, DISPATCH_TIME_FOREVER);

        if (self.ticketSurplusCount &gt; 0) {  // 如果还有票，继续售卖
            self.ticketSurplusCount--;
            NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;剩余票数：%d 窗口：%@&quot;, self.ticketSurplusCount, [NSThread currentThread]]);
            [NSThread sleepForTimeInterval:0.2];
        } else { // 如果已卖完，关闭售票窗口
            NSLog(@&quot;所有火车票均已售完&quot;);

            // 相当于解锁
            dispatch_semaphore_signal(semaphoreLock);
            break;
        }

        // 相当于解锁
        dispatch_semaphore_signal(semaphoreLock);
    }
}
</code></pre>
<p>输出结果为：</p>
<pre><code>2019-08-08 15:23:58.819891+0800 YC-GCD-demo[18116:4348091] currentThread---&lt;NSThread: 0x600000681380&gt;{number = 1, name = main}
2019-08-08 15:23:58.820041+0800 YC-GCD-demo[18116:4348091] semaphore---begin
2019-08-08 15:23:58.820305+0800 YC-GCD-demo[18116:4348159] 剩余票数：49 窗口：&lt;NSThread: 0x6000006ede80&gt;{number = 3, name = (null)}
2019-08-08 15:23:59.022165+0800 YC-GCD-demo[18116:4348157] 剩余票数：48 窗口：&lt;NSThread: 0x6000006e4b40&gt;{number = 4, name = (null)}
2019-08-08 15:23:59.225299+0800 YC-GCD-demo[18116:4348159] 剩余票数：47 窗口：&lt;NSThread: 0x6000006ede80&gt;{number = 3, name = (null)}
...
2019-08-08 15:24:08.355977+0800 YC-GCD-demo[18116:4348157] 剩余票数：2 窗口：&lt;NSThread: 0x6000006e4b40&gt;{number = 4, name = (null)}
2019-08-08 15:24:08.559201+0800 YC-GCD-demo[18116:4348159] 剩余票数：1 窗口：&lt;NSThread: 0x6000006ede80&gt;{number = 3, name = (null)}
2019-08-08 15:24:08.759630+0800 YC-GCD-demo[18116:4348157] 剩余票数：0 窗口：&lt;NSThread: 0x6000006e4b40&gt;{number = 4, name = (null)}
2019-08-08 15:24:08.965100+0800 YC-GCD-demo[18116:4348159] 所有火车票均已售完
2019-08-08 15:24:08.965440+0800 YC-GCD-demo[18116:4348157] 所有火车票均已售完
</code></pre>
<p>可以看出，在考虑了线程安全的情况下，使用 dispatch_semaphore<br>
机制之后，得到的票数是正确的，没有出现混乱的情况。我们也就解决了多个线程同步的问题。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[iOS中的锁]]></title>
        <id>https://fanyuecheng.github.io/post/ios-zhong-de-suo/</id>
        <link href="https://fanyuecheng.github.io/post/ios-zhong-de-suo/">
        </link>
        <updated>2021-01-05T08:01:57.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p><code>Data race</code>(数据竞争)的发生条件：</p>
<p>两个或者更多线程在一个程序中，并发的访问同一数据<br>
至少一个访问是写入操作<br>
些线程都不使用任何互斥锁来控制这些访问<br>
对数据的读取和修改产生了竞争，从而导致各种不可预计的问题。</p>
<p>简单例子</p>
<pre><code>- (void)threadNotSafe {  
    __block NSInteger total = 0;  
    for (NSInteger index = 0; index &lt; 3; index++) {  
        dispatch_async(dispatch_get_global_queue(0, 0), ^{
            // 加锁  
            total += 1;  
            NSLog(@&quot;index: %ld total: %ld&quot;, index, total);  
            total -= 1;  
            NSLog(@&quot;index: %ld total: %ld&quot;, index, total);  
            // 解锁
        });  
    }  
}
</code></pre>
<p>若不加锁，total的值将出现错误</p>
<h2 id="简单概念">简单概念</h2>
<p>1.临界区：指的是一块对公共资源进行访问的代码，并非一种机制或是算法。<br>
2.自旋锁：是用于多线程同步的一种锁，线程反复检查锁变量是否可用。由于线程在这一过程中保持执行，因此是一种忙等待。一旦获取了自旋锁，线程会一直保持该锁，直至显式释放自旋锁。 自旋锁避免了进程上下文的调度开销，因此对于线程只会阻塞很短时间的场合是有效的。<br>
3.互斥锁（Mutex）：是一种用于多线程编程中，防止两条线程同时对同一公共资源（比如全局变量）进行读写的机制。该目的通过将代码切片成一个一个的临界区而达成。<br>
4.读写锁：是计算机程序的并发控制的一种同步机制，也称“共享-互斥锁”、多读者-单写者锁) 用于解决多线程对公共资源读写问题。读操作可并发重入，写操作是互斥的。 读写锁通常用互斥锁、条件变量、信号量实现。<br>
5.信号量（semaphore）：是一种更高级的同步机制，互斥锁可以说是semaphore在仅取值0/1时的特例。信号量可以有更多的取值空间，用来实现更加复杂的同步，而不单单是线程间互斥。<br>
6.条件锁：就是条件变量，当进程的某些资源要求不满足时就进入休眠，也就是锁住了。当资源被分配到了，条件锁打开，进程继续运行。</p>
<h2 id="互斥锁">互斥锁</h2>
<p>1).NSLock：</p>
<pre><code>@protocol NSLocking  
- (void)lock;  
- (void)unlock;  
@end  

@interface NSLock : NSObject &lt;NSLocking&gt; {  
@private  
    void *_priv;  
}  

- (BOOL)tryLock;  
- (BOOL)lockBeforeDate:(NSDate *)limit;  

@property (nullable, copy) NSString *name API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));  

@end
</code></pre>
<p>tryLock和lock方法都会请求加锁，唯一不同的是trylock在没有获得锁的时候可以继续做一些任务和处理。lockBeforeDate:方法也比较简单，就是在limit时间点之前获得锁，没有拿到返回NO。</p>
<p>2).pthread_mutex:</p>
<pre><code>导入头文件 &lt; pthread.h &gt;

pthread_mutex_t _lock;  
pthread_mutex_init(&amp;_lock, NULL);  

pthread_mutex_lock(&amp;_lock);  
pthread_mutex_unlock(&amp;_lock);
</code></pre>
<p>3).@synchronized:</p>
<pre><code>@synchronized(self) {  
    //数据操作  
}
</code></pre>
<h2 id="自旋锁">自旋锁</h2>
<p>1).OSSpinLock:</p>
<pre><code>导入头文件 &lt; libkern/OSSpinLockDeprecated.h &gt;

OSSpinLock lock = OS_SPINLOCK_INIT;  

OSSpinLockLock(&amp;lock);  
OSSpinLockUnlock(&amp;lock);
已经废弃了，它在某一些场景下已经不安全了。
</code></pre>
<p>2).os_unfair_lock:<br>
os_unfair_lock 是苹果官方推荐的替换OSSpinLock的方案，但是它在iOS10.0以上的系统才可以调用。</p>
<pre><code>导入头文件 &lt; os/lock.h &gt;

os_unfair_lock_t unfairLock;  
unfairLock = &amp;(OS_UNFAIR_LOCK_INIT);  

os_unfair_lock_lock(unfairLock);  
os_unfair_lock_unlock(unfairLock);
</code></pre>
<h2 id="读写锁共享-互斥锁">读写锁(共享-互斥锁)</h2>
<p>pthread_rwlock:</p>
<pre><code>导入头文件 &lt; pthread.h &gt;

pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER;
//加读锁  
pthread_rwlock_rdlock(&amp;rwlock);  
//加写锁  
pthread_rwlock_wrlock(&amp;rwlock);  
//解锁  
pthread_rwlock_unlock(&amp;rwlock);
</code></pre>
<h2 id="递归锁">递归锁</h2>
<p>递归锁有一个特点，就是同一个线程可以加锁N次而不会引发死锁。</p>
<p>1).NSRecursiveLock:<br>
与NSLock一样实现了NSLocking协议</p>
<p>2).pthread_mutex(recursive):</p>
<pre><code>pthread_mutex_t lock;  
pthread_mutexattr_t attr;  
pthread_mutexattr_init(&amp;attr);  
pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE);  

pthread_mutex_init(&amp;lock, &amp;attr);  
pthread_mutexattr_destroy(&amp;attr);  
pthread_mutex_lock(&amp;lock);  
pthread_mutex_unlock(&amp;lock);
</code></pre>
<h2 id="条件锁">条件锁</h2>
<p>1).NSCondition:<br>
遵循NSLocking协议，使用的时候同样是lock,unlock加解锁，wait是傻等，waitUntilDate:方法是等一会，都会阻塞掉线程，signal是唤起一个在等待的线程，broadcast是广播全部唤起。</p>
<p>2).NSConditionLock:<br>
基本同 NSCondition。</p>
<p>3).信号量<br>
dispatch_semaphore:</p>
<pre><code>dispatch_semaphore_t lock = dispatch_semaphore_create(1);  
dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER);  
dispatch_semaphore_signal(lock);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[我看RunLoop]]></title>
        <id>https://fanyuecheng.github.io/post/wo-kan-runloop/</id>
        <link href="https://fanyuecheng.github.io/post/wo-kan-runloop/">
        </link>
        <updated>2021-01-05T07:58:06.000Z</updated>
        <content type="html"><![CDATA[<h2 id="ios中的runloop">iOS中的RunLoop</h2>
<p>iOS 系统中，提供了两种RunLoop：NSRunLoop 和 CFRunLoopRef。<br>
CFRunLoopRef 是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。<br>
NSRunLoop 是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。</p>
<p>RunLoop使用场景<br>
保持线程的存活，而不是线性的执行完任务就退出<br>
1). 当线程不开启RunLoop<br>
例子：</p>
<pre><code>@interface TestThread : NSThread  
@end  

@implementation TestThread  
- (void)dealloc {  
    NSLog(@&quot;%@线程被释放了&quot;, self.name);  
}  
@end  

@implementation ViewController  
- (void)viewDidLoad {  
    [super viewDidLoad];

    NSLog(@&quot;%@----开辟子线程&quot;, [NSThread currentThread]);

    TestThread *testThread = [[TestThread alloc] initWithTarget:self selector:@selector(testThreadTodo) object:nil];
    testThread.name = @&quot;testThread&quot;;
    [testThread start]; 
}

- (void)testThreadTodo {
    NSLog(@&quot;%@----执行子线程任务&quot;, [NSThread currentThread]);
}
@end  
</code></pre>
<p>控制台输出：</p>
<pre><code>&lt;NSThread: 0x6000014c7680&gt;{number = 1, name = main}----开辟子线程  
&lt;TestThread: 0x6000014aaf80&gt;{number = 3, name = testThread}----开始执行子线程任务  
testThread线程被释放了
</code></pre>
<p>即：子线程执行完操作就自动退出。</p>
<p>2). 当线程开启RunLoop<br>
若子线程的操作是偶尔或者只需要执行一次的话，像上面那样就没什么问题。但是如果这个操作需要频繁执行，那么按照上面那样的逻辑，我们就需要频繁创建子线程，这样很消耗资源。<br>
我们试试把线程“保持”起来，使控制器持有它，让它在需要的时候执行任务，不需要的时候就啥都不干。<br>
此时，子线程在执行任务结束后不会被释放，但是若再次调用start方法，则程序会崩溃。</p>
<pre><code>*** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '*** -[TestThread start]: attempt to start the thread again'
</code></pre>
<p>执行完任务后，虽然线程没有被释放，还处于内存中，但是它处于死亡状态（当线程的任务结束后就会进入这种状态）。苹果不允许在线程死亡后再次开启。<br>
为了让线程不进入死亡状态，只有让任务一直在进行中，可用一个死循环完成这种效果，但是子线程会不分时间地点场合的疯狂执行任务，并不可取。</p>
<p>此时不持有线程，使用runloop：</p>
<pre><code>- (void)testThreadTodo {
    NSLog(@&quot;%@----开始执行子线程任务&quot;, [NSThread currentThread]);
    //获取当前子线程的RunLoop
    NSRunLoop *runLoop = [NSRunLoop currentRunLoop];
    [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];
    //让RunLoop跑起来
    [runLoop run];
    NSLog(@&quot;%@----执行子线程任务结束&quot;, [NSThread currentThread]);
}
</code></pre>
<p>运行，控制台输出：</p>
<pre><code>&lt;NSThread: 0x600001f79dc0&gt;{number = 1, name = main}----开辟子线程  
&lt;TestThread: 0x600001f12400&gt;{number = 3, name = testThread}----开始执行子线程任务
</code></pre>
<p>最后的打印却没有输出，说明任务并没有结束，线程也没有销毁。<br>
RunLoop本质就是个Event Loop的do while循环，所以运行到[runLoop run]以后子线程就一直在进行接受消息-&gt;等待-&gt;处理的循环。所以不会运行[runLoop run]之后的代码，也就不会因为任务结束导致线程死亡进而销毁。这也就是我们最常使用RunLoop的场景之一，即保持线程的存活，而不是线性的执行完任务就退出。</p>
<p>3). 小结<br>
何为RunLoop<br>
顾名思义就是跑圈，他的本质就是一个do，while循环，当有事做时就做事，没事做时就休眠。</p>
<h2 id="runloop和线程的关系">RunLoop和线程的关系</h2>
<p>RunLoop是保证线程不会退出，并且能在不处理消息的时候让线程休眠，节约资源，在接收到消息的时候唤醒线程做出对应处理的消息循环机制。它是寄生于线程的，线程和RunLoop之间一一对应，主线程的RunLoop会在App运行的时自动运行，子线程需要手动获取运行，第一次获取时，才会去创建。</p>
<p>4). 参考<br>
更深层次就不再赘述了，可参考大神博客：<br>
<a href="https://blog.ibireme.com/2015/05/18/runloop/">深入理解RunLoop</a><br>
<a href="https://www.jianshu.com/p/18afd628ac43">iOS RunLoop入门小结</a></p>
]]></content>
    </entry>
</feed>